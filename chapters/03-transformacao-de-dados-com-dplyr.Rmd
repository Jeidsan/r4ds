# Transformação de dados com `dplyr`

```{r include=FALSE}
not_cancelled <- flights %>%
                    filter(!is.na(dep_delay), !is.na(arr_delay))
```

## Introdução

Não temos exercícios nesta seção.

## Filtrar linhas com `filter()`

Não temos exercícios nesta seção.

## Comparações

### Exercício 3.3.1 {- #exr3-3-1}

::: {.enunciado}
Encontre todos os voos que:

a. Tiveram um atraso de duas horas ou mais na chegada.
b. Foram para Houston (IAH ou HOU).
c. Foram operados pela United, American ou Delta.
d. Partiram em julho, agosto e setembro.
e. Chegaram com mais de duas horas de atraso, mas não saíram atrasados.
f. Atrasaram pelo menos uma hora, mas compensaram mais de 30 minutos durante o trajeto.
g. Saíram entre meia-noite e 6h (incluindo esses horários).
:::

:::{.solution}


a. Tiveram um atraso de duas horas ou mais na chegada.
```{r}
filter(flights, arr_delay >= 120)
```

b. Foram para Houston (IAH ou HOU).
```{r}
filter(flights, dest %in% c("IAH", "HOU"))
```


c. Foram operados pela United, American ou Delta. 
```{r}
filter(flights, carrier %in% c("AA", "DL", "UA"))
```

d. Partiram em julho, agosto e setembro.
```{r}
filter(flights, month %in% c(7, 8, 9))
```

e. Chegaram com mais de duas horas de atraso, mas não saíram atrasados.
```{r}
filter(flights, dep_delay <= 0, arr_delay > 120)
```

f. Atrasaram pelo menos uma hora, mas compensaram mais de 30 minutos durante o trajeto.
```{r}
filter(flights, dep_delay >= 60 & dep_delay - arr_delay >= 30)
```

g. Saíram entre meia-noite e 6h (incluindo esses horários).
```{r}
filter(flights, dep_time >= 0, dep_time <= 600)
```

:::

### Exercício 3.3.2 {- #exr3-3-2}

::: {.enunciado}
Outro ajudante da filtragem do **dplyr** é `between()`. O que ele faz? Você consegue utilizá-lo para simplificar o código necessário para responder os desafios anteriores?
:::

::: {.solution}
O `between` recebe três parâmetros e verifica se o primeiro está entre o segundo e o terceiro.

```{r}
filter(flights, between(dep_time, 0, 600))
```
:::

### Exercício 3.3.3 {- #exr3-3-3}

::: {.enunciado}
Quantos voos têm um `dep_time` faltante? Que outras variáveis estão faltando? O que essas linhas podem representar?
:::

:::{.solution}
```{r}
count(flights, is.na(dep_time))
summary(is.na(flights))
```

São 8255 voos com `dep_time` faltante, o que pode indicar voos cancelados. As seguintes colunas também possuem dados faltantes: `dep_delay`, `arr_time`, `arr_delay`, `tailnum` e `air_time`.
:::

### Exercício 3.3.4 {- #exr3-3-4}

::: {.enunciado}
Por que `NA ^ 0` não é um valor faltante? Por que `NA | TRUE` não é um valor faltante? Por que `FALSE & NA` não é um valor faltante? Você consegue descobrir a regra geral? (`NA * 0` é um contraexemplo complicado!)
:::

:::{.solution}
`NA ^ 0` resulta em um, pois qualquer número real satisfaz essa mesma condição. A regra geral parece ser que, ao avaliar a expressão, sempre que o valor que `NA` representaria for indiferente para o resultado da expressão, então será retornado um valor diferente de `NA`.
:::

## Ordenar linhas com `arrange()`

### Exercício 3.4.1 {- #exr3-4-1}

::: {.enunciado}
Como você poderia usar `arrange()` para classificar todos os valores faltantes no começo? (dica: use `is.na()`.)
:::

:::{.solution}
```{r}
arrange(
  flights, 
  !is.na(year), 
  !is.na(month), 
  !is.na(day), 
  !is.na(dep_time), 
  !is.na(sched_dep_time), 
  !is.na(dep_delay), 
  !is.na(arr_time), 
  !is.na(sched_arr_time), 
  !is.na(arr_delay), 
  !is.na(carrier), 
  !is.na(flight), 
  !is.na(tailnum), 
  !is.na(origin), 
  !is.na(dest), 
  !is.na(air_time), 
  !is.na(distance), 
  !is.na(hour), 
  !is.na(minute), 
  !is.na(time_hour)
)
```

:::

::: {.remark}
Deve haver uma solução muito mais elegante para este problema.
:::

### Exercício 3.4.2 {- #exr3-4-2}

::: {.enunciado}
Ordene `flights` para encontrar os voos mais atrasados. Encontre os voos que saíram mais cedo.
:::

:::{.solution}


Voos mais atrasados:
```{r}
arrange(flights, desc(dep_delay))
```


Voos que saíram mais cedo:
```{r}
arrange(flights, dep_time)
```
:::

### Exercício 3.4.3 {- #exr3-4-3}

::: {.enunciado}
Ordene `flights` para encontrar os voos mais rápidos.
:::

:::{.solution}
```{r}
arrange(flights, air_time)
```
:::

### Exercício 3.4.4 {- #exr3-4-4}

::: {.enunciado}
Quais voos viajaram por mais tempo? Quais viajaram por menos tempo?
:::

:::{.solution}


Voos que viajaram por mais tempo:
```{r}
arrange(flights, desc(air_time))
```

Voos que viajaram por menos tempo:
```{r}
arrange(flights, air_time)
```
:::

## Selecionar colunas com `select()`

### Exercício 3.5.1 {- #exr3-5-1}

::: {.enunciado}
Faça um _brainstorm_ da maior quantidade possível de maneiras de selecionar `dep_time`, `dep_delay`, `arr_time` e `air_delay` de `flights`.
:::

:::{.solution}
x
:::

### Exercício 3.5.2 {- #exr3-5-2}

::: {.enunciado}
O que acontece se você incluir o nome de uma variável varias vezes em uma chamada `select()`?
:::

:::{.solution}
```{r}
select(flights, arr_time, arr_time, arr_time)
```

A variável em questão é selecionada apenas uma vez.
:::

### Exercício 3.5.3 {- #exr3-5-3}

::: {.enunciado}
O que a função `one_of()` faz? Por que poderia ser útil em conjunção com este vetor?
```
vars <- c("year", "month", "day", "dep_delay", "arr_delay")
```

:::

:::{.solution}
```{r}
vars <- c("year", "month", "day", "dep_delay", "arr_delay")
select(flights, one_of(vars)) # superseded in favor of `any_of()`
```

A função  `one_of()`, substituída por `any_of()` serve para indicar que devem ser selecionadas todas as colunas cujos nomes estejam no _array_. 
:::

### Exercício 3.5.4 {- #exr3-5-4}

::: {.enunciado}
O resultado ao executar o código a seguir lhe surpreende? Como as funções auxiliares lidam com o caso por padrão? Como você pode mudar esse padrão?
```
select(flights, contains("TIME"))
```

:::

:::{.solution}
```{r}
select(flights, contains("TIME"))
```

O caso não surpreende. São retornadas todas as colunas que possuem "TIME" em seus nomes, não diferenciando maíusculas e minúsculas. O comportamento pode ser alterado da seguinte forma:

```{r}
select(flights, contains("TIME", ignore.case = FALSE))
```

:::

## Adicionar novas variáveis com `mutate()`

### Exercício 3.6.1 {- #exr3-6-1}

::: {.enunciado}
Atualmente, `dep_time` e `sched_dep_time` são convenientes para observar, mas difíceis de usar para calcular, porque não são realmente números contínuos. Converta-os para uma representação mais apropriada do número de minutos desde a meia-noite.
:::

:::{.solution}
```{r}
(flights_min <- mutate(
                    flights,
                    dep_time_minutes = 60 * (dep_time %/% 100) + (dep_time %% 100),
                    sched_dep_time_minutes = 60 * (sched_dep_time %/% 100) + (sched_dep_time %% 100),
                    arr_time_minutes = 60 * (arr_time %/% 100) + (arr_time %% 100)
                ))
```

:::

### Exercício 3.6.2 {- #exr3-6-2}

::: {.enunciado}
Compare `air_time` e `arr_time - dep_time`. O que você espera ver? O que você vê? O que você precisa fazer para corrigir isso?
:::

:::{.solution}
```{r}
transmute(flights_min, air_time, arr_time_minutes - dep_time_minutes)
```

Como os valores `arr_time` e `dep_time` não são números de fato, a diferença não faz sentido e assim o cálculo gera uma diferença muito grande. Para corrigir isso, primeiro teremos que converter os valores dessas duas variáveis para o número de minutos desde a meia noite e, depois, efetuar a diferença. Ainda assim, pode haver divergência entre esse valor e `air_time`, que pode ser explicada por chegada antecipada, saída atrasada ou porque um vôo chegou ao seu destino após a meia-noite. 
:::

### Exercício 3.6.3 {- #exr3-6-3}

::: {.enunciado}
Compare `dep_time`, `sched_dep_time` e `dep_delay`. Como você espera que esses números estejam relacionados?
:::

:::{.solution}
```{r}
select(flights_min, "dep_time", "sched_dep_time", dep_delay)
```

É esperado que `dep_time = sched_dep_time + dep_delay`.
:::

### Exercício 3.6.4 {- #exr3-6-4}

::: {.enunciado}
Encontre os 10 voos mais atrasados usando uma função de classificação. Como você quer lidar com empates? Leia cuidadosamente a documentação de `min_rank()`.
:::

:::{.solution}
```{r}
filter(
    flights,
    between(rank(desc(flights$dep_delay), ties.method = "min"), 1, 10)
)
```

Usei a função `rank` e os empates foram tratados com o parâmetro `ties.method` setado como `min`.
:::

### Exercício 3.6.5 {- #exr3-6-5}

::: {.enunciado}
O que `1:3 + 1:10` retorna? Por quê?
:::

:::{.solution}
```{r}
1:3 + 1:10
```

Como os vetores têm tamanhos diferentes, a soma vai ser executada entre as posições e, quando o menor dos vetores tiver sido completamente consumido, será tomado novamente o primeiro elemento (como em um movimento circular).
:::

### Exercício 3.6.6 {- #exr3-6-6}

::: {.enunciado}
Quais funções trigonométricas o R fornece?
:::

:::{.solution}
Utilizamos o comando `?cos` para chegar até a documentação do pacote `Trig`, um dos componentes da base do R. 

O R fornece as funções `cos(x)`, `sin(x)`, `tan(x)`, `acos(x)`, `asin(x)`, `atan(x)`, `atan2(y, x)` (arco tangente entre dois vetores), `cospi(x)`, `sinpi(x)` e `tanpi(x)`. 
:::

## Resumos agrupados com `summarize()`

### Exercício 3.7.1 {- #exr3-7-1}

::: {.enunciado}
x
:::

:::{.solution}
x
:::

### Exercício 3.7.2 {- #exr3-7-2}

::: {.enunciado}
x
:::

:::{.solution}
x
:::

### Exercício 3.7.3 {- #exr3-7-3}

::: {.enunciado}
x
:::

:::{.solution}
x
:::

### Exercício 3.7.4 {- #exr3-7-4}

::: {.enunciado}
x
:::

:::{.solution}
x
:::

### Exercício 3.7.5 {- #exr3-7-5}

::: {.enunciado}
x
:::

:::{.solution}
x
:::

### Exercício 3.7.6 {- #exr3-7-6}

::: {.enunciado}
x
:::

:::{.solution}
x
:::

### Exercício 3.7.7 {- #exr3-7-7}

::: {.enunciado}
x
:::

:::{.solution}
x
:::

## Mudanças agrupadas (e filtros)

### Exercício 3.8.1 {- #exr3-8-1}

::: {.enunciado}
x
:::

:::{.solution}
x
:::

### Exercício 3.8.2 {- #exr3-8-2}

::: {.enunciado}
x
:::

:::{.solution}
x
:::

### Exercício 3.8.3 {- #exr3-8-3}

::: {.enunciado}
x
:::

:::{.solution}
x
:::

### Exercício 3.8.4 {- #exr3-8-4}

::: {.enunciado}
x
:::

:::{.solution}
x
:::

### Exercício 3.8.5 {- #exr3-8-5}

::: {.enunciado}
x
:::

:::{.solution}
x
:::

### Exercício 3.8.6 {- #exr3-8-6}

::: {.enunciado}
x
:::

:::{.solution}
x
:::

### Exercício 3.8.7 {- #exr3-8-7}

::: {.enunciado}
x
:::

:::{.solution}
x
:::
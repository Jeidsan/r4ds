# Iteração com `purrr`

Em um dos exercícios desta seção, iremos comparar a performance de dois métodos utilizando o pacote **rbenchmark**.

```{r}
library("rbenchmark")
```


## Introdução

Não temos exercícios para esta seção.

## Loops `for`

### Exercício 17.2.1 {- #exr17-2-1}

::: {.enunciado}
Escreva loops for para:

a. Calcular a média de cada coluna em `mtcars`.
b. Determinar o tipo de cada colunas em `nycflights13::flights`.
c. Calcular o número de valores únicos em cada coluna de `iris`.
d. Gerar 10 valores aleatórias normalmente distribuídos para cada `$mu$ = -10, 0, 10, 100`.

Pense sobre saída, seuência e corpo *antes* de começar a escrever o loop.
:::

::: {.solution}
a. Para calcular a média de cada uma das colunas de `mtcars`, podemos utilizar o seguinte *loop*:
```{r}
output <- vector("double", ncol(mtcars))
for(i in seq_along(mtcars)) {
  output[[i]] <- mean(mtcars[[i]])
}

output
```


b. Para determinar o tipo de cada uma das colunas de `nycflights13::flights`, podemos usar o seguinte:

```{r}
output <- vector("character", ncol(flights))
for (i in seq_along(flights)) {
  output[[i]] <- typeof(flights[[i]])
}

output
```
c. Para calcular o número de valores únicos em cada coluna do dataset `iris`, podemos usar o seguinte:

```{r}
output <- vector("integer", ncol(iris))
for (i in seq_along(iris)) {
  output[[i]] <- iris[[1]] %>% 
                    unique() %>% 
                    length()
}
output
```
d. Para gerar 10 distribuições normais aleatórias para cara um dos valores citados de `$mu$`, podemos usar o seguinte:

```{r}
n <- 10
mu <- c(-10, 0, 10, 100)
normals <- vector("list", length(mu))
for (i in seq_along(normals)) {
  normals[[i]] <- rnorm(n, mean = mu[[i]])
}
str(normals)
```
:::

### Exercício 17.2.2 {- #exr17-2-2}

::: {.enunciado}
Elimine o loop for em cada um dos exemplos a seguir aproveitando umafunção existente que dê certo com vetores.

```
out <- ""
for(x in letters) {
  out <- stringr::str_c(out, x)
}

x <- sample(100)
sd <- 0
for (i in seq_along(x)) {
  sd <- sd + (x[i] - mean(x)) ^ 2
}
sd <- sqrt(sd / (length(x) - 1))

x <- runif(100)
out <- vector("numeric", length(x))
out[1] <- x[1]
for (i in 2:length(x)) {
  out[i] <- out[i - 1] + x[i]
}
```
:::

::: {.solution}
O primeiro loop apenas concatena os valores do vetor, e poderia ser substituído por:

```{r}
stringr::str_c(letters, collapse = "")
```

O segundo loop realiza o cálculo do desvio padrão e poderia ser substituído por:

```{r}
x <- sample(100)
sd <- sd(x)
sd
```
O último loop calcula a soma cumulativa de um vetor e poderia ser substituído por:

```{r}
x <- runif(100)
out <- cumsum(x)
out
```
:::

### Exercício 17.2.3 {- #exr17-2-3}

::: {.enunciado}
Combine suas habilidades de escrita de funções e loops for:

a. Escreva um loop for que imprima (`print()`) a letra da música infantil "Alice the Camel".
b. Converta a cantiga infantil "Ten in the Bed" em uma função. Generalize-a para qualquer número de pessoas em qualquer estrutura de dormir.
c. Converta a música "99 Bottles of Beer on the Wall" em uma função. Generalize-a para qualquer número de qualquer tipo de recipiente contendo qualquer líquido em qualquer superfície.
:::

::: {.solution}
a.

```{r}
humps <- 5
for (i in seq(humps, 0, -1)) {
  cat(
    str_c("Alice the camel has ", rep(i, 3), " humps", collapse = "\n"), 
    collapse = "\n"
  )
  
  if(i == 0) {
    cat("Now Alice is a horse.\n")
  } else {
    cat("So go, Alice, go. Boom, boom, boom!\n\n")
  }
}
```
b. 

```{r}
n_in_the_bed <- function(n = 10, structure = "bed") {
  cat("LYRICS FOR ", n, " IN THE ", str_to_upper(structure), "\n\n")
  
  for (i in n:2) {
    cat("There were ", i, " in the ", structure, "\n")
    cat("And the little one said \"Roll over, roll over\"\n")
    cat("So they all rolled over and one fell out \n\n")
  }

  cat("There was ", i - 1, " in the bad\n")
  cat("And the little one said, \"Goodnight\" \n\n")
}

n_in_the_bed()
n_in_the_bed(5, "rede")
```

c.

```{r}
beverage_in_the_surface <- function(n = 99, recipient = "bottle", beverage = "beer", surface = "wall") {

  for (i in seq(n, 2, -1)) {
    cat(i, " ", recipient, " of ", beverage, " in the ", surface, "\n", collapse = "", sep = "")
    cat("Take one down and pass it around\n", collapse = "", sep = "")
    cat(i - 1, " ", recipient, " of ", beverage, " in the ", surface, "\n\n", collapse = "", sep = "")
  }
  
  if(i == 2) {
    cat(i - 1, " ", recipient, " of ", beverage, " in the ", surface, "\n", collapse = "", sep = "")
    cat("Take one down and pass it around\n", collapse = "", sep = "")
    cat("No more ", recipient, " of ", beverage, " in the ", surface, "\n\n", collapse = "", sep = "")
    
    cat("No more ", recipient, " of ", beverage, " in the ", surface, "\n", collapse = "", sep = "")
    cat("Go to the store and buy some more\n", collapse = "", sep = "")
    cat(n, " ", recipient, " of ", beverage, " in the ", surface, "\n\n", collapse = "", sep = "")
  }
}

beverage_in_the_surface(5, surface = "sofa")
```

:::

### Exercício 17.2.4 {- #exr17-2-4}

::: {.enunciado}
É comum ver loops for que não pré-alocam a saída e, em vez disso, aumentam o comprimento de um vetor a cada passo:

```
output <- vector("integer", 0)
for (i in seq_along(x)) {
  output <- c(output, lengths(x[[i]]))
}
output
```

Como isso afeta o desempenho? Projete e execute um experimento.
:::

::: {.solution}
Para avaliar o benefício de usar a alocação prévia para o vetor de saída, vamos inicialmente definir duas funções. A primeira delas, utiliza a alocação prévia da saída, enquanto a segunda, atualiza o vetor de saída a cada passo. 

```{r}
no_alloc <- function(x) {
  out <- vector("integer", 0)
  for (i in seq_along(x)) {
    out <- c(out, lengths(x[[i]]))
  }
  out
}

with_alloc <- function(x) {
  out <- vector("integer", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- lengths(x[[i]])
  }
  out
}
```

Com as funções definidas, vamos avaliar o tempo de execução utilizando a biblioteca **rbenchmark**. Vamos utilizar um objeto simples como argumento: um vetor com mil números inteiros.

```{r}
x <- 1:1000
benchmark(
  "No allocation" = no_alloc(x), 
  "With allocation" = with_alloc(x)
)
```

Já podemos verificar uma diferença considerável. O método sem alocação prévia demorou aproximadamente 7.5 vezes mais para ser executado!
:::

## Variações do loop `for`

### Exercício 17.3.1 {- #exr17-3-1}

::: {.enunciado}
Imagine que você tenha um diretório cheio de arquivos CSV que deseja ler. Você tem os caminhos deles em um vetor, `files <- dir("data/", pattern = "\\.csv$", full.names = TRUE)`, e agora quer ler cada um com `read_csv()`. Escreva o loop que os carregará em um único data frame.
:::

::: {.solution}
```{r}
files <- dir("data\\", pattern = "\\.csv$", full.names = TRUE)

df <- vector("list", length(files))
for (i in seq_along(files)) {
  df[[i]] <- read_csv(files[[i]])
}

print(df)

df <- bind_rows(df)

print(df)
```

:::

### Exercício 17.3.2 {- #exr17-3-2}

::: {.enunciado}
O que acontece se você usar `for (nm in names(x))` e `x` não tiver nomes? E se somente alguns dos elementos forem nomeados? E se os nomes não forem únicos?
:::

::: {.solution}
Caso o objeto `x` não tenha nomes, nenhum passo do loop será executado.

```{r}
x <- c(1,2,3)
for (nm in names(x)) {
  print(nm)
}
```

Caso apenas alguns dos elementos tenha nome, os elementos não nomeados estarão com a propriedade `name` igual a `NA`, o que resultará em erros explicitos ao tentar buscá-los.

```{r, error = TRUE}
names(x) <- c("a", "b")
for (nm in names(x)) {
  print(x[[nm]])
}
```
Caso tenhamos nomes repetidos, apenas o primeiro elemento será recuperado.

```{r}
names(x) <- c("a", "b", "a")
for (nm in names(x)) {
  print(x[[nm]])
}
```

:::

### Exercício 17.3.3 {- #exr17-3-3}

::: {.enunciado}
Escreva uma função que imprima a média de cada coluna numérica em um data frame, junto com seu nome. Por exemplo, `show_mean(iris)` imprimiria:

```
show_mean(iris)
#> Sepal.Length: 5.84
#> Sepal.Width:  3.06
#> Petal.Length: 3.76
#> Petal.Width:  1.20
```
:::

::: {.solution}
```{r}
show_mean <- function(x, digits = 2) {
  names <- names(x)
  for (i in seq_along(x)) {
    if (is.numeric(x[[i]])) {
      name <- names[[i]]
      mean <- mean(x[[i]], rm.na = TRUE)
      max_length <- max(str_length(names))
      
      cat(
        str_pad(str_c(name, ":"), max_length + 1, side = "right"),
        format(mean, digits = digits, nsmall = digits),
        sep = " ",
        collapse = "\n"
      )
    }
  }
}

show_mean(iris)
```
:::

### Exercício 17.3.4 {- #exr17-3-4}

::: {.enunciado}
O que este código faz? Como ele funciona?

```
trans <- list(
  disp = function(x) x * 0.0163871,
  am = function(x) {
    factor(x, labels = c("auto", "manual"))
  }
)

for (var in names(trans)) {
  mtcars[[var]] <- trans[[var]](mtcars[[var]])
}
```

:::

::: {.solution}
O código altera os valores das colunas `disp` e `am` do data frame `mtcars`. Inicialmente o código define uma lista contendo duas funções (`disp` e `am`) e, após, faz um loop percorrendo os nomes dos elementos nesta lista e, em cada passo, altera o valor da coluna correspondente, chamando a função da lista e passando a coluna como argumento.
:::

## Loops `for` _versus_ funcionais

### Exercício 17.4.1 {- #exr17-4-1}

::: {.enunciado}
Leia a documentação de `apply()`. No segundo caso, quais dois loops `for` ela generaliza?
:::

::: {.solution}
x
:::

### Exercício 17.4.2 {- #exr17-4-2}

::: {.enunciado}
Adapte `col_summary()` para que se aplique apenas a colunas numéricas. Você pode querer começar com uma função `is_numeric()` que retorne um vetor lógico que tenha `TRUE` corespondente a cada coluna numérica.
:::

::: {.solution}
x
:::

## As funções `map`

### Exercício 17.5.1 {- #exr17-5-1}

::: {.enunciado}
x
:::

::: {.solution}
x
:::

### Exercício 17.5.2 {- #exr17-5-2}

::: {.enunciado}
x
:::

::: {.solution}
x
:::

### Exercício 17.5.3 {- #exr17-5-3}

::: {.enunciado}
x
:::

::: {.solution}
x
:::

### Exercício 17.5.4 {- #exr17-5-4}

::: {.enunciado}
x
:::

::: {.solution}
x
:::

### Exercício 17.5.5 {- #exr17-5-5}

::: {.enunciado}
x
:::

::: {.solution}
x
:::

## Lidando com falhas

Não temos exercícios para esta seção.

## Fazendo `map` com vários argumentos

Não temos exercícios para esta seção.

## Walk

Não temos exercícios para esta seção.

## Outros padrões para loops `for`

### Exercício 17.9.1 {- #exr17-9-1}

::: {.enunciado}
x
:::

::: {.solution}
x
:::

### Exercício 17.9.2 {- #exr17-9-2}

::: {.enunciado}
x
:::

::: {.solution}
x
:::

### Exercício 17.9.3 {- #exr17-9-3}

::: {.enunciado}
x
:::

::: {.solution}
x
:::
--- 
title: "R para Data Science"
subtitle: "Solução dos exercícios"
author: "Jeidsan A. da C. Pereira"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: "latex/krantz"
bibliography: 
  - latex/book.bib
  - latex/packages.bib
csl: "latex/abnt.csl"
url: "https://www.jeidsan.com.br/r4ds"
cover-image: "images/cover.png"
description: |
  Esta página contém a solução encontrada por mim para os exercícios propostos no livro R para Data Sciente, de Hadley Wickham e Garret Grolemund, publicado no Brasil em 2019 pela Alta Books Editora.
link-citations: yes
---

```{r setup, include=FALSE}
library(tidyverse)
library(nycflights13)

options(repr.plot.width = 24, repr.plot.height = 13)

tema <- theme(
        plot.title   = element_text(size = 14, vjust = +2, hjust = 0.5),
        axis.title.y = element_text(size = 12, vjust = +4),
        axis.title.x = element_text(size = 12, vjust = -2),
        axis.text.y  = element_text(size = 10),
        axis.text.x  = element_text(size = 10),
        legend.text  = element_text(size = 10),
        strip.text   = element_text(size = 10)
    )
```

# Prefácio {-}

Esta página serviu para estudo e prática com o pacote R Bookdown e contém a solução encontrada por mim para os exercícios propostos no livro R para Data Sciente, de Hadley Wickham e Garret Grolemund, publicado no Brasil em 2019 pela Alta Books Editora [@wickham2019].

```{r fig.align='center', echo=FALSE, include=identical(knitr:::pandoc_to(), 'html'), out.width='250px'}
knitr::include_graphics('images/cover.png', dpi = NA)
```

Por se tratar de um produto construído durante o processo de aprendizagem, o conteúdo pode conter erros, tanto no texto em si, como na lógica utilizada para solução dos exercícios.

Dúvidas ou sugestões de melhoria podem ser encaminhadas para o e-mail *jeidsan.pereira@gmail.com*.

## Pendências {-}

- No PDF, o prefácio está sendo exibido duas vezes no sumário;
- [Exercício 1.7.4](#exr1-7-4);
- [Exercício 2.3.3](#exr2-3-3);
- [Exercício 3.5.1](#exr3-5-1);
- [Exercício 3.7.1](#exr3-7-1);
- [Exercício 3.8.1](#exr3-8-1);
- [Exercício 4.2.1](#exr4-2-1);
- [Exercício 4.2.2](#exr4-2-2);
- [Exercício 5.5.4](#exr5-5-4);
- [Exercício 5.5.8](#exr5-5-8);
- [Exercício 5.5.9](#exr5-5-9);
- [Exercício 5.5.12](#exr5-5-12);
- [Exercício 8.2.3](#exr8-2-3);
- [Exercício 8.3.6](#exr8-3-6);
- 

<!--chapter:end:index.Rmd-->

\mainmatter

# (PART) Explorar {-}

# Visualização de dados com `ggplot2`

Para a correta execução dos códigos desse capítulo, utilizaremos algumas configurações específicas.

Inicialmente, precisaremos carregar o pacote `nycflights13`, que contém os dados de todos os voos da cidade de Nova York em 2013.

```{r}
library(nycflights13)
library(gridExtra)
```

## Introdução

Não temos exercícios nesta seção.

## Primeiros passos

### Exercício 1.2.1 {- #exr1-2-1}

:::{.enunciado}
Execute `ggplot(data=mpg);`. O que você vê?
:::

:::{.solution}
```{r}
ggplot(data=mpg) +
    tema
```

É exibido um quadro em branco. Este quadro contém o sistema de coordenadas sobre o qual serão desenhados os grpaficos que pretendemos exibir.
:::

### Exercício 1.2.2 {- #exr1-2-2}

::: {.enumciado}
Quantas linhas existem em `mtcars`? Quantas colunas?
:::

:::{.solution}
```{r}
dim(mtcars)
```

R.: Existem 32 linhas e 11 colunas.
:::

### Exercício 1.2.3 {- #exr1-2-3}

::: {.enunciado}
O que a variável `drv` descreve?
:::

:::{.solution}

Executamos o comando `?mpg` no console no R e a página de ajuda foi aberta. Nela encontramos o significado de cada variável do conjunto de dados.

A varíável descreve o tipo de tração dos carros analisados, onde `f` significa tração dianteira, `r` significa tração traseira e `4` significa tração nas quatro rodas.
:::

### Exercício 1.2.4 {- #ex1-2-4}

::: {.enunciado}
Faça um gráfico de dispersão de `hwy` _versus_ `cyl`.
:::

::: {.solution}

```{r}
ggplot(data = mpg) +
    geom_point(mapping = aes(x = hwy, y = cyl)) +
    tema
```
:::

### Exercício 1.2.5 {- #exr1-2-5}

::: {.enunciado}
O que acontece se você fizer um gráfico de dispersão de `class` _versus_ `drv`? Por que esse gráfico não é útil?
:::

:::{.solution}
```{r}
ggplot(data = mpg) +
    geom_point(mapping = aes(x = drv, y = class)) +
    tema
```

Apesar de serem exibidos dados no gráfico, nenhuma informação substancial é extraída, uma vez que o tipo de tração não está (a princípio) relacionado com a categoria do carro. Outro fator que torno o gráfico pouco informativo é que há, por exemplo, diversas SUVs com tração nas 4 rodas, contudo os valores ficam sobrepostos no gráfico, não dando dimensão do quanto de dados temos.

Abaixo seguem duas opções de como trazer mais informação ao gráfico:

- a primeira opção adiciona um ruído aos dados (`position = jitter` ou `geom_jitter()`) de modo que não haja sobreposição;

```{r}
ggplot(data = mpg) +
    geom_point(mapping = aes(x = drv, y = class), position = "jitter") +
    tema
```

- a segunda opção, bem mais avançada, adiciona uma estética de `size` considerando a quantidade de registros.

```{r}
mpg %>%
    group_by(class, drv) %>%
    summarize(count = n()) %>%
    ggplot(mapping = aes(x = drv, y = class, size = count)) +
        geom_point() +
        tema
```
:::

## Mapeamentos estéticos

### Exercício 1.3.1 {- #exr1-3-1}

::: {.enunciado}
O que há de errado com este código? Por que os pontos não estão azuis?

```{r}
ggplot(data = mpg) +
    geom_point(mapping = aes(x = displ, y = hwy, color = "blue")) +
    tema
```
:::

:::{.solution}

Ao invés de atribuir uma cor aos elementos de `geom_point`, o atributo `color` foi passado como uma estética. O gráfico deveria ser construído da seguinte maneira:

```{r}
ggplot(data = mpg) +
    geom_point(mapping = aes(x = displ, y = hwy), color = "blue") +
    tema
```
:::

### Exercício 1.3.2 {- #exr1-3-2}

::: {.enunciado}
Quais variáveis em `mpg` são categóricas? Quais variáveis são contínuas? Como você pode ver essa informação quando executa `mpg`?
:::

:::{.solution}

Usando `?mpg` vemos que as variáveis categóricas são: `manufacturer`, `model`, `trans`, `drv`, `fl` e `class`. As variáveis contínuas são: `displ`, `cty`, `hwy`.
:::

### Exercício 1.3.3 {- #exr1-3-3}

::: {.enunciado}
Mapeie uma variável contínua para `color`, `size` e `shape`. Como essas estéticas se comportam de maneira diferente para variáveis categóricas e contínuas?
:::

:::{.solution}
```{r}
ggplot(data = mpg) +
    geom_point(mapping = aes(x = displ, y = hwy, color = displ)) +
    tema
```

```{r}
ggplot(data = mpg) +
    geom_point(mapping = aes(x = displ, y = hwy, size = displ)) +
    tema
```

```{r error=TRUE}
ggplot(data = mpg) +
    geom_point(mapping = aes(x = displ, y = hwy, shape = displ)) +
    tema
```

Quando possível, a biblioteca _ggplot_ apesenta a estética em um gradiente, como em color e size. Porém, nem sempre isso é possível, como vemos em `shape`, que só pode ser utilizada com variáveis discretas ou categóricas.
:::

### Exercício 1.3.4 {- #exr1-3-4}

::: {.enunciado}
O que acontece se você mapear a mesma variável a várias estéticas?
:::

:::{.solution}
```{r}
ggplot(data = mpg) +
    geom_point(mapping = aes(x = displ, y = hwy, size = class, color = class, shape = class)) +
    tema
```

Os valores da variável serão representados de modo a atender todas as estéticas simultaneamente, por exemplo, no gráfico acima é dada uma cor, um formato e um tamanho específicos para cada classe de veículo. Os veículos de dois lugares são exibidos como um disco rosa pequeno.
:::

### Exercício 1.3.5 {- #exr1-3-5}

::: {.enunciado}
O que a estética `stroke` faz? com que formas ela trabalha?
:::

:::{.solution}
```{r}
ggplot(data = mpg) +
    geom_point(mapping = aes(x = displ, y = hwy, stroke = displ)) +
    tema
```

A estética `stroke` controla a espessura do ponto ou elemento a ser representado.
:::

### Exercício 1.3.6 {- #exr1-3-6}

::: {.enunciado}
O que acontece se você mapear uma estética a algo diferente de um nome de variável, como `aes(color = displ < 5)`?
:::

::: {.solution}
```{r}
ggplot(data = mpg) +
    geom_point(mapping = aes(x = displ, y = hwy, color = displ < 5)) +
    tema
```

A expressão é avaliada para cada um dos valores da variável e o resultado é utilizado para plotagem da estética no gráfico.
:::

## Problemas comuns

Não temos exercícios nessa seção.

## Facetas

### Exercício 1.5.1 {- #exr1-5-1}

::: {.enunciado}
O que acontece se você criar facetas em uma variável contínua?
:::

:::{.solution}
```{r}
ggplot(data = mpg) +
    geom_point(mapping = aes(x = displ, y = hwy)) +
    facet_wrap(. ~ displ) +
    tema
```

O _ggplot_ se encarrega de dividir o conjunto em classes e toma o ponto médio de cada classe para realizar a quebra em facetas.
:::

### Exercício 1.5.2 {- #exr1-5-2}

::: {.enunciado}
O que significam as célula em branco em um gráfico com `facet_grid(drv ~ cyl)`? Como elas se relacionam a este gráfico?

```{r}
ggplot(data = mpg) +
    geom_point(mapping = aes(x = displ, y = hwy)) +
    facet_grid(drv ~ cyl) +
    tema
```
:::

:::{.solution}
Significa que para aquela combinação de variáveis, não há nenhum valor observado. Por exemplo, não há nenhum veículo com 5 cilindros e tração nas quatro rodas.
:::

### Exercício 1.5.3 {- #exr1-5-3}

::: {.enunciado}
Que gráficos o código a seguir faz? O que `.` faz?

```{r}
ggplot(data = mpg) +
    geom_point(mapping = aes(x = displ, y = hwy)) +
    facet_grid(drv ~ .) +
    tema
```

```{r}
ggplot(data = mpg) +
    geom_point(mapping = aes(x = displ, y = hwy)) +
    facet_grid(. ~ cyl) +
    tema
```
:::

:::{.solution}
São gerados os gráficos de dispersão segregados pelas variáveis `drv` e `cyl`, respectivamente. O `.` indica que não queremos considerar nenhuma segregação naquela dimensão do _grid_ (linha ou coluna).
:::

### Exercício 1.5.4 {- #exr1-5-4}

::: {.enunciado}
Pegue o primeiro gráfico em facetas dessa seção.

```{r}
ggplot(data = mpg) +
    geom_point(data = transform(mpg, class = NULL), mapping = aes(x = displ, y = hwy), color = "gray80") +
    geom_point(mapping = aes(x = displ, y = hwy)) +
    facet_wrap(~ class, nrow = 2) +
    tema
```

Quais são as vantagens de usar facetas, em vez de estética de cor? Quais são as desvantagens? Como o equilíbrio poderia mudar se você tivesse um conjunto de dados maior?
:::

:::{.solution}
A principal vantagem no uso de facetas é que fica mais fácil analisar os dados quando eles estão separados em seu próprio contexto, contudo visualizá-los assim dificulta a comparação entre grupos.
:::

### Exercício 1.5.5 {- #exr1-5-5}

::: {.enunciado}
Leia `?facet_wrap`. O que `nrow` faz? o que `ncol` faz? Quais outras opções controlam o layout de paineis individuais? Por que `facet_grid()` não tem variáveis `nrow`e `ncol`?
:::

:::{.solution}
```
?facet_wrap
```

Os atributos `ncol` e `nrow` são utilizados pelo `facet_wrap` para determinar o número de colunas ou linhas (respectivamente) nas quais serão distribuídos os gráficos segregados. Esses atributos não figuram em `facet_grid` pelo fato deste já organizar as facetas retangularmente.
:::

### Exercício 1.5.6 {- #exr1-5-6}

::: {.enunciado}
Ao usar `facet_grid()` você normalmente deveria colocar a variável com níveis mais singulares nas colunas. Por quê?
:::

:::{.solution}
Para melhor aproveitamento do espaço em tela.
:::

## Objetos geométricos

### Exercício 1.6.1 {- #exr1-6-1}

::: {.enunciado}
Que _geom_ você usaria para desenhar um gráfico de linha? Um diagrama de caixas (_boxplot_)? Um histograma? Um gráfico de área?
:::

:::{.solution}
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
    geom_line() +
    tema
```

```{r}
ggplot(data = mpg) +
    geom_boxplot(mapping = aes(y = hwy, x = class)) +
    tema
```

```{r}
ggplot(data = mpg, mapping = aes(x = hwy)) +
    geom_histogram() +
    tema
```

```{r}
ggplot(data = economics, mapping = aes(x = date, y = unemploy)) +
    geom_area() +
    tema
```

Podem ser utilizados, respectivamente as _geoms_: _line_, _boxplot_, _histogram_ e _area_.
:::

### Exercício 1.6.2 {- #exr1-6-2}

::: {.enunciado}
Execute este código em sua cabeça e preveja como será o resultado. Depois execute o código no R e confira suas previsões:

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) +
    geom_point() +
    geom_smooth(se = FALSE) +
    tema
```
:::

:::{.solution}
O gráfico bateu com a expectativa.
:::

### Exercício 1.6.3 {- #exr1-6-3}

::: {.enunciado}
O que o `show.legend = FALSE` faz? O que acontece se você removê-lo? Por que você acha que usei isso anteriormente no capítulo?
:::

:::{.solution}
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) +
    geom_point(show.legend = FALSE) +
    geom_smooth(se = FALSE, show.legend = FALSE) +
    tema
```

Ele indica que, para a camada à qual se aplica, não serão geradas as legendas de identificação.
:::

### Exercício 1.6.4 {- #exr1-6-4}

::: {.enunciado}
O que o argumento `se` para `geom_smooth` faz?
:::

:::{.solution}
```
?geom_smooth
```

Esse argumento indica se o intervalo de confiança utilizado no processo de suavização da linha deve ou não ser exibido no gráfico.
:::

### Exercício 1.6.5 {- #exr1-6-5}

::: {.enunciado}
Esses dois gráficos serão diferentes? Por quê/por que não?

```
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
    geom_point() +
    geom_smooth() +
    tema
    
ggplot() + 
    geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) +
    geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy)) +
    tema
```
:::

:::{.solution}
Os gráficos serão iguais. Ao informar os parâmetros `data` e `mapping` na função `ggplot` essas atributos serão considerados como globais, sendo utilizado em todos as camadas do gráfico, a menos que alguma das camadas os sobrescreva. No segundo gráfico, não são definidos parâmetros globais, porém, o mesmo parâmetro é passado para ambas as camadas, sendo assim, a única diferença é o código estar duplicado. 
:::

### Exercício 1.6.6 {- #exr1-6-6}

::: {.enunciado}
Recrie o código R necessário para gerar os seguintes gráficos:

```{r echo=FALSE, warning=FALSE, message=FALSE}
a <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
        geom_point() +
        geom_smooth(se = FALSE) +
        tema

b <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
        geom_point() +
        geom_smooth(mapping = aes(group = drv), se = FALSE) +
        tema

c <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) +
        geom_point() +
        geom_smooth(se = FALSE) +
        tema

d <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
        geom_point(mapping = aes(color = drv)) +
        geom_smooth(se = FALSE) +
        tema

e <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
        geom_point(mapping = aes(color = drv)) +
        geom_smooth(mapping = aes(linetype = drv), se = FALSE) +
        tema

f <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy, fill = drv)) +
        geom_point(color = "white", shape = 21, size = 3, stroke = 2) +
        tema

grid.arrange(a, b, c, d, e, f, nrow = 3)
```
:::

:::{.solution}
```
a <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
        geom_point() +
        geom_smooth(se = FALSE) +
        tema

b <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
        geom_point() +
        geom_smooth(mapping = aes(group = drv), se = FALSE) +
        tema

c <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) +
        geom_point() +
        geom_smooth(se = FALSE) +
        tema

d <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
        geom_point(mapping = aes(color = drv)) +
        geom_smooth(se = FALSE) +
        tema

e <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
        geom_point(mapping = aes(color = drv)) +
        geom_smooth(mapping = aes(linetype = drv), se = FALSE) +
        tema

f <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy, fill = drv)) +
        geom_point(color = "white", shape = 21, size = 3, stroke = 2) +
        tema
```
:::

## Transformações estatísticas

### Exercício 1.7.1 {- #exr1-7-1}

::: {.enunciado}
Qual é o `geom` padrão associado ao `stat_summary()`? Como você poderia reescrever o gráfico anterior usando essa função `geom`, em vez da função `stat`?
:::

:::{.solution}
```
?stat_summary
```

```{r}
ggplot(data = diamonds) +
    stat_summary(
        mapping = aes(x = cut, y = depth),
        fun.min = min,
        fun.max = max,
        fun = median
    ) +
    tema
```

A `geom` associada é a `geom_pointrange` e o gráfico poderia ser reescrito da seguinte maneira.
:::

### Exercício 1.7.2 {- #exr1-7-2}

::: {.enunciado}
O que `geom_col()` faz? Qual é a diferença entre ele e `geom_bar()`?
:::

:::{.solution}
```{r}
ggplot(data = diamonds, mapping = aes(x = cut)) +
    geom_bar() +
    tema
```

```{r}
ggplot(data = diamonds, mapping = aes(x = cut, y = carat)) +
    geom_col() +
    tema
```

Enquanto no `geom_bar` a altura das barras representa uma transformação estatística relacionada às observações (como `count`, por exemplo), no `geom_col` podemos exibir o acumulado (soma) de uma variável para cada categoria exibida.
:::

### Exercício 1.7.3 {- #exr1-7-3}

::: {.enunciado}
A maioria dos `geoms` e `stats` vem em pares, que são quase sempre usados juntos. Leia a documentação e faça uma lista de todos os pares. O que eles têm em comum?
:::

:::{.solution}
| #  | Geom             | Stat              |
|:--:|:----------------:|:-----------------:|
| 01 | Blank            | Identity          |
| 02 | Curve            | Identity          |
| 03 | Segment          | Identity          |
| 04 | Path             | Identity          |
| 05 | Line             | Identity          |
| 06 | Step             | Identity          |
| 07 | Poligon          | Identity          |
| 08 | Raster           | Identity          |
| 09 | Rect             | Identity          |
| 10 | Tile             | Identity          |
| 11 | Ribbon           | Identity          |
| 12 | Area             | Identity          |
| 13 | Align            | ?                 |
| 14 | ABLine           | ?                 |
| 15 | HLine            | ?                 |
| 16 | Density          | Density           |
| 17 | DotPlot          | ?                 |
| 18 | Freqpoly         | Bin               |
| 19 | Histogram        | Bin               | 
| 20 | Col              | Identity          |
| 21 | Bar              | Count             |
| 22 | Label            | Identity          |
| 23 | Text             | Identity          |
| 24 | Jitter           | Identity          |
| 25 | Point            | Identity          |
| 26 | Quantile         | Quantile          |
| 27 | Rug              | Identity          |
| 28 | Boxplot          | Boxplot           |
| 29 | Violin           | YDensity          |
| 30 | Count            | Sum               |
| 31 | Bin 2D           | Bin 2D            |
| 32 | Density 2D       | Density 2D        |
| 33 | Hex              | Bin Hex           |
| 34 | Cross Bar        | Identity          |
| 35 | Error Bar        | Identity          |
| 36 | Line Range       | Identity          |
| 37 | Point Range      | Identity          |
| 38 | Map              | Identity          |
| 39 | Contour          | Contour           |
| 40 | Contour Filled   | Contour Filled    |
:::

### Exercício 1.7.4 {- #exr1-7-4}

::: {.enunciado}
Quais variáveis `stat_smooth()` calcula? Quais parâmetros controlam seu comportamento?
:::

:::{.solution}
```
?stat_smooth
```


:::

### Exercício 1.7.5 {- #exr1-7-5}

::: {.enunciado}
Em nosso gráfico de barra de _proportion_, precisamos configurar `group = 1`. Por quê? Em outras palavras, qual é o problema com esses dois gráficos?

```{r}
ggplot(data = diamonds) +
    geom_bar(mapping = aes(x = cut, y = after_stat(prop), group = 1)) +
    tema
```
:::

:::{.solution}
```{r}
ggplot(data = diamonds) +
    geom_bar(mapping = aes(
        x = cut, 
        fill = color, 
        y = after_stat(prop), 
        group = color
    )) +
    tema
```

Quando estamos trabalhando com proporções (ou estátisticas em geral), é importante destacar para o `ggplot` qual agrupamento ele deve considerar, caso contrário ele irá considerar um único grupo e dará uma impressão incorreta ao gráfico. No primeiro exemplo, foi utilizado `group = 1` (e, na verdade, poderia ser qualquer valor) apenas para indicar que deveria ser realizado um agrupamento.
:::

## Ajustes de posição

### Exercício 1.8.1 {- #exr1-8-1}

::: {.enunciado}
Qual é o problema com este gráfico? Como você poderia melhorá-lo?

```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
    geom_point() +
    tema
```
:::

:::{.solution}
Há pontos sobrepostos. Uma melhoria poderia ser usar `geom_jitter` em lugar de `geom_point`.

```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
    geom_jitter() +
    tema
```
:::

### Exercício 1.8.2 {- #exr1-8-2}

::: {.enunciado}
Quais parâmetros para `geom_jitter` controlam a quantidade de oscilação?
:::

:::{.solution}
Conforme a documentação disposta em `?geom_jitter`, são utilizados os parâmetros `width` e `height`.
:::

### Exercício 1.8.3 {- #exr1-8-3}

::: {.enunciado}
Compare o contraste entre `geom_jitter` e `geom_count`.
:::

:::{.solution}
```{r}
a <- ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
      geom_jitter() +
      tema

b <- ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
      geom_count(show.legend = FALSE) +
      tema

grid.arrange(a, b, nrow = 2)
```

Para contornar o problema da sobreposição de pontos, `geom_jitter` adiciona um pequeno ruído aleatório aos dados, enquanto o `geom_count` contabiliza os pontos sobrepostos e altera o tamanho dos pontos conforme a quantidade.
:::

### Exercício 1.8.4 {- #exr1-8-4}

::: {.enunciado}
Qual é o ajuste de posição padrão para `geom_boxplot()`? Crie uma visualização do conjunto de dados `mpg` que demonstre isso.
:::

:::{.solution}
Conforme pode ser visto em `?geom_boxplot`, a `position` padrão é a `dodge2`.

```{r}
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) +
    geom_boxplot() +
    tema
```
:::

## Sistemas de coordenadas

### Exercício 1.9.1 {- #exr1-9-1}

::: {.enunciado}
Transforme um gráfico de barras empilhadas em um gráfico de pizza usando `coord_polar()`.
:::

:::{.solution}
```{r}
ggplot(data = diamonds, mapping = aes(x = cut, fill = cut)) +
    geom_bar(show.legend = FALSE, width = 1) +
    coord_polar() +
    labs(x = NULL, y = NULL) +
    theme(aspect.ratio = 1) +
    tema
```

:::

### Exercício 1.9.2 {- #exr1-9-2}

::: {.enunciado}
O que `labs()` faz? Leia a documentação.
:::

:::{.solution}
Usando o comando `?labs`, vimos que esta função é utilizada para definir labels do gráfico, como título, subtítulo, títulos de eixos, etc.
:::

### Exercício 1.9.3 {- #exr1-9-3}

::: {.enunciado}
Qual é a diferença entre `coord_quickmap()` e `coord_map()`?
:::

:::{.solution}
Usando o comando `?coord_map`, notamos que a diferença é que enquanto `coord_map()` não preserva linhas retas, sendo assim, mais custoso computacionalmente, o `coord_quickmap()` o faz.
:::

### Exercício 1.9.4 {- #exr1-9-4}

::: {.enunciado}
O que o gráfico a seguir lhe diz sobre a relação entre `mpg` de cidade e estrada? Por que `coord_fixed()` é importante? O que `geom_abline()` faz?

```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
    geom_point() +
    geom_abline() +
    coord_fixed(ratio = 1, xlim = c(5, 45), ylim = c(5, 45)) +
    tema
```
:::

:::{.solution}
O gráfico mostra a relação entre a eficiência na cidade e na estrada. O `coord_fixed()` força que seja mantida uma proporção entre os eixos x e y, isto é, garante que uma unidade no eixo y corresponda a um número determinado de unidades no eixo x. A razão padrão é 1. Já o `geom_abline()` define uma linha de referência diagonal ao gráfico, no nosso caso, a linha é a reta dada por $y - x = 0$.
:::

## A gramática em camadas de gráficos

Não temos exercícios nesta seção.

<!--chapter:end:chapters/01-visualizacao-de-dados-com-ggplot2.Rmd-->

# Fluxo de trabalho: o básico

## O básico de programação

Não temos exercícios nesta seção.

## O que há em um nome?

Não temos exercícios nesta seção.

## Chamando funções

### Exercício 2.3.1 {- #exr2-3-1}

::: {.enunciado}
Por que esse código não funciona?

```
my_variable <- 10
my_varIable
```
:::

:::{.solution}
Foi atribuído um valor à variável `my_variable`, contudo depois tentou-se utilizar essa variável, porém a escrita está incorreta e o `R` não reconheceu a variável. 
O `R` diferencia letras maiúsculas e minúsculas, isto é, as variáveis `my_variable` e `my_varIable` são distintas.
:::

### Exercício 2.3.2 {- #exr2-3-2}

::: {.enunciado}
Ajuste cada um dos seguintes comandos de `R` para que executem corretamente.

```
library(tidyverse)

ggplot(dota = mpg) +
    geom_point(mapping = aes(x = displ, y = hwy))
    
filter(mpg, cyl = 8)
filter(diamond, carat > 3)
```
:::

:::{.solution}
```{r}
library(tidyverse)

ggplot(data = mpg) +
    geom_point(mapping = aes(x = displ, y = hwy))
    
filter(mpg, cyl == 8)
filter(diamonds, carat > 3)
```
:::

### Exercício 2.3.3 {- #exr2-3-3}

::: {.enunciado}
Pressione Alt-Shift-K. O que acontece? Como você pode chegar ao mesmo resultado usando os menus?
:::

:::{.solution}
x
:::

<!--chapter:end:chapters/02-fluxo-de-trabalho-o-basico.Rmd-->

# Transformação de dados com `dplyr`

Para este capítulo, necessitaremos das seguintes configurações iniciais:

```{r}
not_cancelled <- flights %>%
                    filter(!is.na(dep_delay), !is.na(arr_delay))
```

## Introdução

Não temos exercícios nesta seção.

## Filtrar linhas com `filter()`

Não temos exercícios nesta seção.

## Comparações

### Exercício 3.3.1 {- #exr3-3-1}

::: {.enunciado}
Encontre todos os voos que:

a. Tiveram um atraso de duas horas ou mais na chegada.
b. Foram para Houston (IAH ou HOU).
c. Foram operados pela United, American ou Delta.
d. Partiram em julho, agosto e setembro.
e. Chegaram com mais de duas horas de atraso, mas não saíram atrasados.
f. Atrasaram pelo menos uma hora, mas compensaram mais de 30 minutos durante o trajeto.
g. Saíram entre meia-noite e 6h (incluindo esses horários).
:::

:::{.solution}


a. Tiveram um atraso de duas horas ou mais na chegada.
```{r}
filter(flights, arr_delay >= 120)
```

b. Foram para Houston (IAH ou HOU).
```{r}
filter(flights, dest %in% c("IAH", "HOU"))
```


c. Foram operados pela United, American ou Delta. 
```{r}
filter(flights, carrier %in% c("AA", "DL", "UA"))
```

d. Partiram em julho, agosto e setembro.
```{r}
filter(flights, month %in% c(7, 8, 9))
```

e. Chegaram com mais de duas horas de atraso, mas não saíram atrasados.
```{r}
filter(flights, dep_delay <= 0, arr_delay > 120)
```

f. Atrasaram pelo menos uma hora, mas compensaram mais de 30 minutos durante o trajeto.
```{r}
filter(flights, dep_delay >= 60 & dep_delay - arr_delay >= 30)
```

g. Saíram entre meia-noite e 6h (incluindo esses horários).
```{r}
filter(flights, dep_time >= 0, dep_time <= 600)
```

:::

### Exercício 3.3.2 {- #exr3-3-2}

::: {.enunciado}
Outro ajudante da filtragem do **dplyr** é `between()`. O que ele faz? Você consegue utilizá-lo para simplificar o código necessário para responder os desafios anteriores?
:::

::: {.solution}
O `between` recebe três parâmetros e verifica se o primeiro está entre o segundo e o terceiro.

```{r}
filter(flights, between(dep_time, 0, 600))
```
:::

### Exercício 3.3.3 {- #exr3-3-3}

::: {.enunciado}
Quantos voos têm um `dep_time` faltante? Que outras variáveis estão faltando? O que essas linhas podem representar?
:::

:::{.solution}
```{r}
count(flights, is.na(dep_time))
summary(is.na(flights))
```

São 8255 voos com `dep_time` faltante, o que pode indicar voos cancelados. As seguintes colunas também possuem dados faltantes: `dep_delay`, `arr_time`, `arr_delay`, `tailnum` e `air_time`.
:::

### Exercício 3.3.4 {- #exr3-3-4}

::: {.enunciado}
Por que `NA ^ 0` não é um valor faltante? Por que `NA | TRUE` não é um valor faltante? Por que `FALSE & NA` não é um valor faltante? Você consegue descobrir a regra geral? (`NA * 0` é um contraexemplo complicado!)
:::

:::{.solution}
`NA ^ 0` resulta em um, pois qualquer número real satisfaz essa mesma condição. A regra geral parece ser que, ao avaliar a expressão, sempre que o valor que `NA` representaria for indiferente para o resultado da expressão, então será retornado um valor diferente de `NA`.
:::

## Ordenar linhas com `arrange()`

### Exercício 3.4.1 {- #exr3-4-1}

::: {.enunciado}
Como você poderia usar `arrange()` para classificar todos os valores faltantes no começo? (dica: use `is.na()`.)
:::

:::{.solution}
```{r}
arrange(
  flights, 
  !is.na(year), 
  !is.na(month), 
  !is.na(day), 
  !is.na(dep_time), 
  !is.na(sched_dep_time), 
  !is.na(dep_delay), 
  !is.na(arr_time), 
  !is.na(sched_arr_time), 
  !is.na(arr_delay), 
  !is.na(carrier), 
  !is.na(flight), 
  !is.na(tailnum), 
  !is.na(origin), 
  !is.na(dest), 
  !is.na(air_time), 
  !is.na(distance), 
  !is.na(hour), 
  !is.na(minute), 
  !is.na(time_hour)
)
```

:::

::: {.remark}
Deve haver uma solução muito mais elegante para este problema.
:::

### Exercício 3.4.2 {- #exr3-4-2}

::: {.enunciado}
Ordene `flights` para encontrar os voos mais atrasados. Encontre os voos que saíram mais cedo.
:::

:::{.solution}


Voos mais atrasados:
```{r}
arrange(flights, desc(dep_delay))
```


Voos que saíram mais cedo:
```{r}
arrange(flights, dep_time)
```
:::

### Exercício 3.4.3 {- #exr3-4-3}

::: {.enunciado}
Ordene `flights` para encontrar os voos mais rápidos.
:::

:::{.solution}
```{r}
arrange(flights, air_time)
```
:::

### Exercício 3.4.4 {- #exr3-4-4}

::: {.enunciado}
Quais voos viajaram por mais tempo? Quais viajaram por menos tempo?
:::

:::{.solution}


Voos que viajaram por mais tempo:
```{r}
arrange(flights, desc(air_time))
```

Voos que viajaram por menos tempo:
```{r}
arrange(flights, air_time)
```
:::

## Selecionar colunas com `select()`

### Exercício 3.5.1 {- #exr3-5-1}

::: {.enunciado}
Faça um _brainstorm_ da maior quantidade possível de maneiras de selecionar `dep_time`, `dep_delay`, `arr_time` e `air_delay` de `flights`.
:::

:::{.solution}
x
:::

### Exercício 3.5.2 {- #exr3-5-2}

::: {.enunciado}
O que acontece se você incluir o nome de uma variável varias vezes em uma chamada `select()`?
:::

:::{.solution}
```{r}
select(flights, arr_time, arr_time, arr_time)
```

A variável em questão é selecionada apenas uma vez.
:::

### Exercício 3.5.3 {- #exr3-5-3}

::: {.enunciado}
O que a função `one_of()` faz? Por que poderia ser útil em conjunção com este vetor?
```
vars <- c("year", "month", "day", "dep_delay", "arr_delay")
```

:::

:::{.solution}
```{r}
vars <- c("year", "month", "day", "dep_delay", "arr_delay")
select(flights, one_of(vars)) # superseded in favor of `any_of()`
```

A função  `one_of()`, substituída por `any_of()` serve para indicar que devem ser selecionadas todas as colunas cujos nomes estejam no _array_. 
:::

### Exercício 3.5.4 {- #exr3-5-4}

::: {.enunciado}
O resultado ao executar o código a seguir lhe surpreende? Como as funções auxiliares lidam com o caso por padrão? Como você pode mudar esse padrão?
```
select(flights, contains("TIME"))
```

:::

:::{.solution}
```{r}
select(flights, contains("TIME"))
```

O caso não surpreende. São retornadas todas as colunas que possuem "TIME" em seus nomes, não diferenciando maíusculas e minúsculas. O comportamento pode ser alterado da seguinte forma:

```{r}
select(flights, contains("TIME", ignore.case = FALSE))
```

:::

## Adicionar novas variáveis com `mutate()`

### Exercício 3.6.1 {- #exr3-6-1}

::: {.enunciado}
Atualmente, `dep_time` e `sched_dep_time` são convenientes para observar, mas difíceis de usar para calcular, porque não são realmente números contínuos. Converta-os para uma representação mais apropriada do número de minutos desde a meia-noite.
:::

:::{.solution}
```{r}
(flights_min <- mutate(
                    flights,
                    dep_time_minutes = 60 * (dep_time %/% 100) + (dep_time %% 100),
                    sched_dep_time_minutes = 60 * (sched_dep_time %/% 100) + (sched_dep_time %% 100),
                    arr_time_minutes = 60 * (arr_time %/% 100) + (arr_time %% 100)
                ))
```

:::

### Exercício 3.6.2 {- #exr3-6-2}

::: {.enunciado}
Compare `air_time` e `arr_time - dep_time`. O que você espera ver? O que você vê? O que você precisa fazer para corrigir isso?
:::

:::{.solution}
```{r}
transmute(flights_min, air_time, arr_time_minutes - dep_time_minutes)
```

Como os valores `arr_time` e `dep_time` não são números de fato, a diferença não faz sentido e assim o cálculo gera uma diferença muito grande. Para corrigir isso, primeiro teremos que converter os valores dessas duas variáveis para o número de minutos desde a meia noite e, depois, efetuar a diferença. Ainda assim, pode haver divergência entre esse valor e `air_time`, que pode ser explicada por chegada antecipada, saída atrasada ou porque um vôo chegou ao seu destino após a meia-noite. 
:::

### Exercício 3.6.3 {- #exr3-6-3}

::: {.enunciado}
Compare `dep_time`, `sched_dep_time` e `dep_delay`. Como você espera que esses números estejam relacionados?
:::

:::{.solution}
```{r}
select(flights_min, "dep_time", "sched_dep_time", dep_delay)
```

É esperado que `dep_time = sched_dep_time + dep_delay`.
:::

### Exercício 3.6.4 {- #exr3-6-4}

::: {.enunciado}
Encontre os 10 voos mais atrasados usando uma função de classificação. Como você quer lidar com empates? Leia cuidadosamente a documentação de `min_rank()`.
:::

:::{.solution}
```{r}
filter(
    flights,
    between(rank(desc(flights$dep_delay), ties.method = "min"), 1, 10)
)
```

Usei a função `rank` e os empates foram tratados com o parâmetro `ties.method` setado como `min`.
:::

### Exercício 3.6.5 {- #exr3-6-5}

::: {.enunciado}
O que `1:3 + 1:10` retorna? Por quê?
:::

:::{.solution}
```{r}
1:3 + 1:10
```

Como os vetores têm tamanhos diferentes, a soma vai ser executada entre as posições e, quando o menor dos vetores tiver sido completamente consumido, será tomado novamente o primeiro elemento (como em um movimento circular).
:::

### Exercício 3.6.6 {- #exr3-6-6}

::: {.enunciado}
Quais funções trigonométricas o R fornece?
:::

:::{.solution}
Utilizamos o comando `?cos` para chegar até a documentação do pacote `Trig`, um dos componentes da base do R. 

O R fornece as funções `cos(x)`, `sin(x)`, `tan(x)`, `acos(x)`, `asin(x)`, `atan(x)`, `atan2(y, x)` (arco tangente entre dois vetores), `cospi(x)`, `sinpi(x)` e `tanpi(x)`. 
:::

## Resumos agrupados com `summarize()`

### Exercício 3.7.1 {- #exr3-7-1}

::: {.enunciado}
Faça um *brainstorming* de pelo menos cinco maneiras diferentes de avaliar as características do atraso típico de um grupo de voos. Considere os seguintes cenários:

- Um voo está 15 minutos adiantado em 50% do tempo e 15 minutos atrasado em 50% do tempo.
- Um voo está sempre 10 min atrasado.
- Um voo está 30 minutos adiantado em 50% do tempo e 30 minutos atrasado em 50% do tempo.
- Em 99% do tempo um voo está no horário. Em 1% do tempo, está 2 horas atrasado.

O que é mais importante: atrsado na chegada ou atraso na partida?
:::

:::{.solution}
x
:::

### Exercício 3.7.2 {- #exr3-7-2}

::: {.enunciado}
Crie outra abordagem que lhe dará o mesmo resultado que `not_cancelled %>% count(dest)` e `not_cancelled %>% count(tailnum, wt = distance)` (sem usar `count()`).
:::

:::{.solution}
```{r}
not_cancelled %>%
    group_by(dest) %>%
    summarise(n = n())

not_cancelled %>%
    group_by(tailnum) %>%
    summarise(n = sum(distance))
```

:::

### Exercício 3.7.3 {- #exr3-7-3}

::: {.enunciado}
Nossa definição de voos cancelados (`is.na(dep_delay) | is.na(arr_delay)`) é ligeiramente insuficiente. Por quê? Qual é a coluna mais importante?
:::

:::{.solution}
As váriáveis `dep_delay` e `arr_delay` se referem ao atraso na partida ou na chegada dos voos. Caso um voo tenha saído e chegado no horário exato, esses valores podem estar `NA`, ou seja, o voo não foi cancelado, apenas partiu e chegou no horário planejado. Nesse caso, o mais correto seria considerar como cancelados os voos `dep_time` é `NA`. 
:::

### Exercício 3.7.4 {- #exr3-7-4}

::: {.enunciado}
Veja o número de voos cancelados por dia. Existe um padrão? A proporção de voos cancelados está relacionado ao atraso médio?
:::

:::{.solution}
```{r}
cancelled_by_day <- flights %>%
                        group_by(year, month, day) %>%
                        summarise(
                            date = as.Date(paste(year, month, day, sep='-')),
                            count = n(),
                            count_cancelled = sum(is.na(dep_time)),
                            count_not_cancelled = sum(!is.na(dep_time)),
                            mean_dep_delay = mean(dep_delay, na.rm = TRUE),
                            mean_arr_delay = mean(arr_delay, na.rm = TRUE),
                        )

cancelled_by_day %>%
    ggplot(aes(mean_dep_delay, count_cancelled / count)) +
        geom_point() +
        geom_smooth(se = FALSE) +
        labs(
            title = "Número de voos cancelados conforme o tempo médio de atraso no dia",
            x = "Tempo médio de atraso na partida (min)",
            y = "Número de cancelamentos"
        ) +
        xlim(0, 80) +
        ylim(0, 0.3) +
        tema
```

Parece existir uma relação entre o número de coos cancelados no dia e a média de atraso nos voos desse mesmo dia. Caso haja alguma condição desfavorável (tempo ruim, problemas na pista de decolagem/pouso, etc), o intervalo entre uma decolagem/pouso e outro pode aumentar significativamente gerando atrasos que se acumulam a ponto de alguns voos terem que ser cancelados (esse comportamento é real?).
:::

### Exercício 3.7.5 {- #exr3-7-5}

::: {.enunciado}
Qual companhia tem os piores atrasos? Desafio: você consegue desembaralhar o efeito dos aeroportus ruins *versus* companhiars ruins? Por quê/Por que não? ( Dica: pense em `flights %>% group_by(cartier, dest) %>% summarize(n())`)
:::

:::{.solution}
Para verificar qual companhia tem os piores atrasos, vamos calcular o atraso médio por companhia.

```{r}
flights %>% 
    group_by(carrier) %>% 
    summarize(
        mean_delay = mean(arr_delay, na.rm = TRUE)
    ) %>%
    arrange(desc(mean_delay))
```

Podemos notar que a companhia com o maior atraso médio é a F9 (Frontier Airlines Inc).

Para tentar desembaralhar o efeito de aeroportos ruins e companhias ruins, vamos:

- filtrar apenas os voos com atraso;
- agrupar os voos conforme as rotas e companhias;
- calcular o atraso médio e o total de voos por companhia no trecho (`arr_delay` e `flights`);
- calcular o atraso médio e o total de voos do trecho de todas as companhias (`arr_delay_total` e `flights_total`);
- calcular o atraso médio por voo da companhia (`arr_delay_mean <- arr_delay / flights`);
- calcular o atraso "médio" das demais companhias (`arr_delay_others <- (arr_delay_total - arr_delay) / (flights_total - fligths)`);
- calcular a diferença entre o atraso médio da companhia e o atraso médio das outras companhias juntas (`arr_delay_diff <- arr_delay_mean - arr_delay_others`);
- remover valores cuja diferença não faça sentido (`is.finite(arr_delay_diff)`);
- agrupar por companhia;
- calcular a média das diferenças de atraso da companhia (`arr_delay_diff`);

```{r}
(atrasos <- flights %>% 
                filter(!is.na(arr_delay)) %>%
                group_by(origin, dest, carrier) %>%
                summarise(
                    arr_delay = sum(arr_delay),
                    flights = n()
                ) %>%
                group_by(origin, dest) %>%
                mutate(
                    arr_delay_total = sum(arr_delay),
                    flights_total = sum(flights)
                ) %>%
                ungroup() %>%
                mutate(        
                    arr_delay_mean = arr_delay / flights, # atraso médio da companhia
                    arr_delay_others = (arr_delay_total - arr_delay) / (flights_total - flights), # atraso médio das demais companhias
                    arr_delay_diff = arr_delay_mean - arr_delay_others # diferença do atraso em relação às demais companhias
                ) %>%
                filter(is.finite(arr_delay_diff)) %>%
                group_by(carrier) %>%
                summarise(
                    arr_delay_diff = mean(arr_delay_diff)
                ) %>%
                arrange(desc(arr_delay_diff)))
```

Desconsiderando o efeito de trechos e aeroportos ruins, a companhia com maior atraso é a OO (SkyWest Airlines Inc.).

```{r}
atrasos %>%
    left_join(airlines, by = "carrier") %>%
    ggplot(aes(
        arr_delay_diff, 
        reorder(name, desc(arr_delay_diff))
    )) +
        geom_col() +
        labs(
            title = "Atrasos por companhia aérea",
            y = "Companhia aérea",
            x = "Tempo médio de atraso (em min.)"
        ) +
        tema
```

:::

### Exercício 3.7.6 {- #exr3-7-6}

::: {.enunciado}
Para cada avião, conte o número de voos antes do primeiro atraso de mais de uma hora.
:::

:::{.solution}
Utilizando a variável `flight` para identificar o voo e a variável `arr_delay` como parâmetro para determinar o tempo de atraso:

- ordenamos o data-frame conforme a hora agendada para decolagem;
- agrupamos pelo número do voo;
- utilizamos as funções `first()` e `which()` para buscar a posição do primeiro elemento que é `NA` ou o atraso é maior do que 60 min.

Obs.: `NA` indica que aquele voo não teve nenhum atraso superior a 60 min.

```{r}
flights %>%
    arrange(time_hour) %>%    
    group_by(flight) %>%
    summarise(
        first_delay_pos = first(which(is.na(arr_delay) | arr_delay > 60)) - 1
    )
```

:::

### Exercício 3.7.7 {- #exr3-7-7}

::: {.enunciado}
O que o argumento `sort` para `count()` faz? Quando você pode usá-lo?
:::

:::{.solution}
Utilizando o comando `?count`, identificamos que o argumento `sort` organiza a contagem em ordem decrescente.
:::

## Mudanças agrupadas (e filtros)

### Exercício 3.8.1 {- #exr3-8-1}

::: {.enunciado}
Volte à tabela de funções de mudança e filtragem úteis. Descreva como cada operaçõa muda quando você as combina com o agrupamento.
:::

:::{.solution}
x
:::

### Exercício 3.8.2 {- #exr3-8-2}

::: {.enunciado}
Qual avião (`tailnum`) tem o pior registro de pontualidade?
:::

:::{.solution}
Vamos inicialmente considerar que um voo é pontual se o tempo de atraso na chegada (`arr_delay`) é igual ou inferior a zero e, para considerar um avião como mais ou menos pontual, levaremos em consideração a proporção de voos pontuais que ele realizou.

```{r}
flights %>%
    # Considerar apenas os registros que tem a informação sobre o avião, 
    # hora de chegada e atraso na chegada
    filter(!is.na(tailnum), !is.na(arr_time), !is.na(arr_delay)) %>%
    # Criar uma variável booleana (0 ou 1) que indica se o voo foi pontual
    mutate(
        on_time = !is.na(arr_time) & arr_delay <= 0
    ) %>%
    # Calcular a proporção de voos pontuais e o número de voos por avião
    group_by(tailnum) %>%
    summarise(
        n = n(),
        arr_delay = mean(arr_delay),
        on_time = mean(on_time)
    ) %>%
    # Descartar aviões que voaram 20 vezes ou menos
    filter(n > 20) %>%
    # Ordenar por percentiual de voos pontuais
    arrange(desc(on_time)) %>%
    head()
```

Com base na configuração acima, o avião N382HA é o mais pontual, com 88,46% dos 26 voos sendo executados com pontualidade.
:::

### Exercício 3.8.3 {- #exr3-8-3}

::: {.enunciado}
A que horas você deverá voar se quiser evitar atrasos ao máximo.
:::

:::{.solution}
O problema depende de encontrar o horário em que ocorrem menos atrasos. Consideraremos a hora inteira como parâmetro para a busca (`hour`) e utilizaremos a média dos tempos de atraso dos voos.

```{r}
flights %>%
    filter(!is.na(hour)) %>%
    group_by(hour) %>%
    summarise(
        arr_delay = mean(arr_delay, na.rm = T)
    ) %>%
    arrange(arr_delay) %>%
    head()
```
:::

### Exercício 3.8.4 {- #exr3-8-4}

::: {.enunciado}
Para cada destino, calcule os minutos totais de atraso. Para cada voo, calcule a proporção de atraso total par seu destino.
:::

:::{.solution}
R.: Para calcular o atraso total (em minutos) por destino, somaremos os valores da variável `arr_delay` de todos os voos para cada destino (`group_by(dest)`). Em seguida, para calcular a proporção com a qual cada voo colabora para o atraso total do destino, utilizaremos a razão entre o atraso do voo e o total do grupo ao qual pertence.

```{r}
flights %>%
    filter(arr_delay > 0) %>%
    group_by(dest) %>%
    mutate(
        arr_delay_total = sum(arr_delay),
        arr_delay_prop = arr_delay / arr_delay_total
    ) %>%
    select (dest, flight, dep_time, arr_delay, arr_delay_total, arr_delay_prop) %>%
    arrange(dest, desc(arr_delay_prop)) %>%
    head()
```
:::

### Exercício 3.8.5 {- #exr3-8-5}

::: {.enunciado}
Atrasos são normalmente temporariamente correlacionados: mesmo quando o problema que causou o atraso inicial foi resolvido, , voos posteriores atrasam para permitir que os voos anteriores decolem. Usando `lag()`, explore como o atraso de um voo está relacionado com o atraso imediatamente anterior.
:::

::: {.solution}
Considerando o atraso na decolagem, vamos inicialmente ordenar os voos por aeroporto, data e hora da decolagem. Em seguida, agrupando pelo aeroporto, coletamos o atraso do voo anteriot (note que o `mutate` irá atuar sobre o grupo apenas. Não faz sentido considerar o voo anterior em outro aeroporto!). Na sequência, podemos agrupar pelo tempo de atraso do voo anterior para calcular a média dos atrasos dos voos. Por fim, é exibido o gráfico.

Avaliando a imagem, podemos notar a tendência de que, quanto maior o atraso do voo imediatamente anterior, maior será o atraso do voo atual. O padrão crescente segue até atrasos de aproximadamente 435 minutos. Depois passa a decrescer, o que deve ser analisado mais aprofundadamente.

```{r}
flights %>%
    arrange(origin, month, day, dep_time) %>%
    group_by(origin) %>%
    mutate(prev_dep_delay = lag(dep_delay)) %>%
    filter(!is.na(dep_delay), !is.na(prev_dep_delay)) %>%
    group_by(origin, prev_dep_delay) %>%
    summarise(dep_delay_mean = mean(dep_delay)) %>%
    ggplot(aes(prev_dep_delay, dep_delay_mean)) +
        geom_point() +
        geom_smooth(se = FALSE) +        
        scale_x_continuous(breaks = seq(0, 1300, by = 60)) +
        scale_y_continuous(breaks = seq(0, 450, by = 60)) +
        labs(
            title = "Atraso médio na decolagem em função do atraso na decolagem anterior.",
            x = "Atraso na decolagem anterior (min.)",
            y = "Atraso médio na decolagem (min.)"
        ) +
        tema
```

É importante notar que o padrão se repete se avaliarmos cada aeroporto individualmente.

```{r}
flights %>%
    arrange(origin, month, day, dep_time) %>%
    group_by(origin) %>%
    mutate(prev_dep_delay = lag(dep_delay)) %>%
    filter(!is.na(dep_delay), !is.na(prev_dep_delay)) %>%
    group_by(origin, prev_dep_delay) %>%
    summarise(dep_delay_mean = mean(dep_delay)) %>%
    ggplot(aes(prev_dep_delay, dep_delay_mean)) +
        geom_point() +
        geom_smooth(se = FALSE) +
        facet_wrap(~ origin, ncol = 1) +
        scale_x_continuous(breaks = seq(0, 1300, by = 60)) +
        scale_y_continuous(breaks = seq(0, 450, by = 60)) +
        labs(
            title = "Atraso médio na decolagem em função do atraso na decolagem anterior.",
            x = "Atraso na decolagem anterior (min.)",
            y = "Atraso médio na decolagem (min.)"
        ) +
        tema
```

:::

### Exercício 3.8.6 {- #exr3-8-6}

::: {.enunciado}
Veja cada destino. Você consegue encontrar os voos que são suspeitamente rápidos? (Ou seja, voos que representam um erro de entrada de dados em potencial). Calcule o tempo de viagem de um voo relativo ao voo mais curto para aquele destino. Quais voos ficaram mais atrasados no ar?
:::

::: {.solution}
Inicialmente calcularemos a média e o desvio padrão para cada rota (`origin`, `dest`) e, na sequência, calcularemos o *z-score* para avaliar a distribuição dos tempos de voo. Usaremos a mediana e o intervalo interquartílico para escapar do efeito de outliers.

```{r}
standardized <- flights %>%
    filter(!is.na(air_time)) %>%            # Remover os voos sem informação do tempo de voo
    group_by(origin, dest) %>%              # Agrupar pela rota (origin -> dest)
    mutate(
        median = median(air_time),          # Calcular a média de cada grupo
        iqr = IQR(air_time),                # Calcular o desvio padrão do grupo
        n = n(),                            # Calcular o tamanho do grupo
        z = (air_time - median) / iqr       # Calcular o z-score de cada voo dentro do grupo
    ) %>%
    ungroup()

standardized %>%    
    ggplot(aes(x = z)) +
        geom_density() +
        geom_vline(aes(xintercept = -2.5), linetype = "dashed") +
        geom_vline(aes(xintercept = 2.5), linetype = "dashed") +
        scale_x_continuous(breaks = seq(-10, 30, by = 1)) +
        tema
```

Os voos com *z-score* muito baixo, são aqueles cujo tempo de voo foi muito menor do que a média, ou seja, os mais rápidos. 

```{r}
standardized %>%
    arrange(z) %>%
    select(carrier, flight, origin, dest, month, day, air_time, median, iqr, z) %>%
    head(10)
```

Adicionalmente, vamos considerar também a velocidade do voo (`mph <- distance / (air_time / 60)`).

```{r}
standardized %>%
    mutate(
        mph = distance / (air_time / 60)
    ) %>%
    ggplot(aes(x = mph)) +
        geom_histogram(binwidth = 10) +
        scale_x_continuous(breaks = seq(0, 700, by = 50)) +
        tema

standardized %>%
    mutate(
        mph = distance / (air_time / 60)
    ) %>%
    arrange(desc(mph)) %>%
    select(carrier, flight, origin, dest, month, day, mph) %>%
    head(10)
```

Algum conhecimento prévio nos indica que a a velocidade superior a 550 milhas por hora são suspeitamente altas. 

Note que, em ambas as análises, coicidiram quase todos os voos. Poderíamos fazer análises mais acuradas, se tivéssemos mais conhecimento sobre o domínio de negócio, contudo já podemos concluir que aqueles são os voos suspeitos.
:::

### Exercício 3.8.7 {- #exr3-8-7}

::: {.enunciado}
Encontre todos os destinos que são feitos por pelo menos duas companhias. Use essa informação para classificar as companhias.
:::

::: {.solution}
```{r}
flights %>%
    filter(!is.na(arr_delay)) %>%                           # Remover os elementos que não tem informação de atraso
    group_by(origin, dest) %>%                              # Agrupar pela origem e destino
    mutate(
        carrier_count = n_distinct(carrier),                # Calcular quantas empresas fazem o trecho
        arr_delay_mean = mean(arr_delay),                   # Calcular o atraso médio do trecho
        arr_delay_percent = arr_delay / arr_delay_mean      # Calcular a proporção do atraso em relação à média do trecho
    ) %>%
    filter(carrier_count > 1) %>%                           # Considerar apenas trechos operados por mais de uma empresa    
    group_by(origin, dest, carrier) %>%
    summarise(
        arr_delay = mean(arr_delay_percent)
    ) %>%
    arrange(origin, dest, desc(arr_delay)) %>%
    head(25)
```
:::

<!--chapter:end:chapters/03-transformacao-de-dados-com-dplyr.Rmd-->

# Fluxo de trabalho: scripts

## Executando códigos

Não temos exercícios neste seção.

## Diagnósticos Rstudio

### Exercício 4.2.1 {- #exr4-2-1}

::: {.enunciado}
Vá para a conta RStudio Tips no Twitter, em *@rstudiotips*, e escolha uma dica que pareça interessante. Pratique o uso dessa dica!
:::

:::{.solution}
x
:::


### Exercício 4.2.2 {- #exr4-2-2}

::: {.enunciado}
Quais outros erros comuns o diagnóstico do RStudio reportará? Leia *http://bit.ly/RStudiocodediag* para descobrir.
:::

:::{.solution}
x
:::

<!--chapter:end:chapters/04-fluxo-de-trabalh-scripts.Rmd-->

# Análise exploratória de dados

## Introdução

Não temos exercícios nesta seção.

## Perguntas

Não temos exercícios nesta seção.

## Variação

### Exercício 5.3.1 {- #exr5-3-1}

::: {.enunciado}
Explore a distribuição de cada variável `x`, `y` e `z` em `diamonds`. O que você aprende? Pense em um diamante e como você pode determinar qual dimensão é o comprimento, a largura e a profundidade.
:::

:::{.solution}
Por se tratar de variáveis continuas, vamos utilizar um gráfico de densidade (ou histograma) para visualizar os dados.

Como x e y possuem distribuição mais parecisa, acredita-se que tratam-se do comprimento e da largura do diamante, sendo z a profundidade (por ter média menor).

```{r}
plot <- diamonds %>% 
          ggplot() + 
            coord_cartesian(
              xlim = c(0, 10),
              ylim = c(0, .85)
            ) +
            scale_x_continuous(breaks = seq(0, 10, by = 1)) +
            labs(
              y = ""
            ) +
            tema

x <- plot + geom_density(aes(x))
y <- plot + geom_density(aes(y))
z <- plot + geom_density(aes(z))

grid.arrange(x, y, z, nrow = 3)
```

```{r}
diamonds %>% 
  # Remover os outliers
  filter(0 < x, x <= 10, 0 < y, y <= 10) %>%
  ggplot(aes(x, y)) +
    # Mostrar a densidade de x e y em conjunto
    geom_density2d() +                      
    # Mostrar uma linha guia para visualizar se x e Y crescem de forma 
    # proprocional, isto é, se os diamantes são quadrados/redondos
    geom_abline(
      aes(intercept = 0, slope = 1),
      linetype = "dashed"
    ) +
    # Arrumar a proporção do gráfico
    coord_cartesian(
      xlim = c(3.5, 8.5),
      ylim = c(3.5, 8.5)
    ) +
    # Aplicar o tema padrão
    tema
```

:::

### Exercício 5.3.2 {- #exr5-3-2}

::: {.enunciado}
Explore a distribuição de `price`. Você identifica algo incomun ou surpreendente? (Dica: pense cuidadosamente sobre `binwidth` e certifique-se de experimentar uma ampla gama de valores).
:::

:::{.solution}
```{r}
summary(diamonds)
```

```{r}
diamonds %>%
    ggplot(aes(x = price)) +
        geom_histogram(binwidth = 100) +
        tema
```

:::

### Exercício 5.3.3 {- #exr5-3-3}

::: {.enunciado}
Quantos diamantes têm 0,99 quilates? Quantos têm 1 quilate? Qual você acha que é a causa dessa diferença?
:::

:::{.solution}
Existem 23 diamantes com 0.99 quilates, contra 1558 diamantes com 1 quilate. Provavelmente a concentração de diamantes de 1 quilate se deve a arredondamento.

```{r}
diamonds %>%
    filter(carat >= .99, carat <= 1) %>%
    count(carat)
```
:::

### Exercício 5.3.4 {- #exr5-3-4}

::: {.enunciado}
Compare e contraste `coord_cartesian` *versus* `xlim()` ou `ylim()` ao dar zoom em um histograma. O que acontece se você não configurar `binwidth`? O que acontece se você tentar dar zoom para que apenas meia barra seja mostrada?
:::

:::{.solution}
Ao utilizar `coord_cartesian()` a restrição nos eixos `x` e `y` ocorrem após calculados os valores do gráfico e desenhados os geoms, dessa forma, o cálculo não é afetado pelos limites, apenas é feito o zoom. Já para `xlim` e `ylim`, os filtros são aplicados antes da construção do gráfico e as restrições são levadas em consideração, dessa forma, temos pontos que serão realmente descartados, e o leiaute do gráfico acaba ficando bem diferente.

```{r}
diamonds %>%
    ggplot(aes(carat)) +
        geom_histogram() +
        xlim(0,1) +
        tema
```

```{r}
diamonds %>%
    ggplot(aes(carat)) +
        geom_histogram() +
        coord_cartesian(xlim = c(0,1)) +
        tema
```

:::

## Valores faltantes

### Exercício 5.4.1 {- #exr5-4-1}

::: {.enunciado}
O que acontece com valores faltantes em um histograma? O que ocorre com valores faltantes em um gráfico de barras? Por que há uma diferença?
:::

:::{.solution}
A construção de um histograma considera valores continuos, dessa forma os valores faltantes são descartados, uma vez que não é possível dispor valores faltantes na ordenação dos valores (`NA > 0` não resulta em um valor lógico). Já para o gráfico de barras, como são considerados valores categóricos, os valores faltantes são exibidos como uma nova categoria.

```{r}
diamonds2 <- diamonds %>%
                mutate(y = ifelse(y < 3 | y > 20, NA, y))

diamonds2 %>%
    ggplot(aes(x = y)) +
        geom_histogram() +
        tema
```

```{r}
diamonds3 <- diamonds2 %>%
                mutate(cut = ifelse(is.na(y), NA, as.character(cut)))

diamonds3 %>%    
    ggplot(aes(x = cut)) +
        geom_bar() +
        tema
```

:::

### Exercício 5.4.2 {- #exr5-4-2}

::: {.enunciado}
O que `na.rm = TRUE` faz em `mean()` e `sum()`?
:::

:::{.solution}
O parâmetro `na.rm` serve para indicar que devem ser excluídos da soma ou da média os valores faltantes.

```{r}
a <- c(1, 2, 3, 4, NA, 6, 7, 8, 9, 10)
mean(a)
mean(a, na.rm = TRUE)
sum(a)
sum(a, na.rm = TRUE)
```
:::


## Covariação

### Exercício 5.5.1 {- #exr5-5-1}

::: {.enunciado}
Use o que você aprendeu para melhorar a visualização dos tempos de decolagem dos coos cancelados *versus* não cancelados.
:::

:::{.solution}
```{r}
flights %>%
    mutate(
        cancelled = ifelse(is.na(dep_time), "Cancelled", "Not cancelled"),
        sched_hour = sched_dep_time %/% 100,
        sched_min = sched_dep_time %% 100,
        sched_dep_time = sched_hour + (sched_min / 60)
    ) %>%    
    ggplot(aes(cancelled, sched_dep_time)) +
        geom_boxplot() +
        tema
    

```
:::

### Exercício 5.5.2 {- #exr5-5-2}

::: {.enunciado}
Qual variável no conjunto de dados dos diamantes é mais importante para prever o preço de um diamante? Como essa variável está correlacionada ao corte (`cut`)? Por que a combinação desses dois relacionamentos leva a diamantes de menor qualidade serem mais caros?
:::

:::{.solution}
Vamos considerar na análise as seguintes variáveis: `carat`, `cut`, `color` e `clarity`.

Para ãvaliar a correlação entre `carat` e `price` (duas variáveis contínuas), podemos usar `geom_point()`, `geom_boxplot()` com a variável independente discretizada ou `geom_quantile()`. Vamos avaliar o melhor dos cenários:

```{r}
diamonds %>% 
    ggplot(aes(carat, price)) +
        geom_point() +
        tema
```

```{r}
diamonds %>%
    ggplot(aes(carat, price)) +
        geom_boxplot(aes(group = cut_width(carat, .1))) +
        tema
```

Com base nas imagens acima, podemos ver que existe uma relação positiva entre `carat` e `price`, o que indica que possivelmente essas duas variáveis estão bem correlacionadas. Note ainda que a representação via boxplot ficou um pouco melhor do que a representação por pontos.

Vamos agora avaliar a variável `cut`. Por se tratar de uma variável discreta, podemos utilizar `geom_col()`, `geom_boxplot()`, `geom_dotplot()` ou `geom_violin()`. Vamos avaliar cada um deles.

```{r}
diamonds %>%
    ggplot(aes(cut, price)) +
        geom_col() +
        tema
```

```{r}
diamonds %>%
    ggplot(aes(cut, y = price)) +
        geom_boxplot() +
        tema
```

```{r}
diamonds %>%
    ggplot(aes(cut, price)) +
        geom_dotplot(binaxis = "y") +
        tema
```

```{r}
diamonds %>%
    ggplot(aes(cut, price)) +
        geom_violin(scale = "area") +
        tema
```

Notamos que os gráficos gerados por `geom_col()` e `geom_dotplot()` não geraram nenhum resultado interessante. Este devido à poluição visual e aquele devido a mostrar uma contagem dos elementos em cada grupo, e não a associação entre as variáveis.

Tanto com `geom_boxplot()`, quanto com `geom_violin()`, podemos perceber que há uma correlação negativa muito fraca entre as variáveis e, desta forma, podemos considerar que `cut` não é interessante para predizer os preços dos diamantes.

Sigamos para a variável `color`:

```{r}
diamonds %>% 
    ggplot(aes(color, price)) +
        geom_boxplot() +
        tema
```

```{r}
diamonds %>% 
    ggplot(aes(color, price)) +
        geom_violin(scale = "area") +
        tema
```

Como podemos perceber, a relação entre as variáveis não é significativa, portanto, descartaremos `color`.

Seguindo em frente, precisamos avaliar a variável `clarity`:

```{r}
diamonds %>% 
    ggplot(aes(clarity, price)) +
        geom_boxplot() +
        tema
```

```{r}
diamonds %>% 
    ggplot(aes(color, price)) +
        geom_violin(scale = "area") +
        tema
```

Notamos também que a variável não tem correação com o preço.

Concluímos, portanto, que a melhor variável para predizer o preço do diamante é `carat`.

Agora, avaliaremos a relação entre `carat` e `cut`.

```{r}
diamonds %>%
    ggplot(aes(cut, carat)) +
        geom_boxplot() +
        tema
```

Há uma relação negativa muito leve entre `cut` e `carat`, mas isso não é suficiente para dizer que uma impacta na outra. Há grande variabilidade de `carat` dentro de cada tipo de corte (`cut`) e, nota-se, os diamantes de grande quilate (provavelmente pedras grandes), tem um corte apenas justo. Isso pode se dar ao fato de que, quanto menor o diamante, melhor precisa ser o corte para que se consiga um bom valor. Além disso, é presumível que é mais fácil vender um diamante pequeno do que um grande, por isso talvez o preço não seja tão alto.
:::

### Exercício 5.5.3 {- #exr5-5-3}

::: {.enunciado}
Instale o pacote **ggstance** e crie um boxplot horizontal. Como isso se compara a usar `coord_flip()`?
:::

:::{.solution}
```{r}
library(ggstance)

diamonds %>%
    ggplot(aes(carat, cut)) +
        geom_boxploth() +
        tema
```

```{r}
diamonds %>%
    ggplot(aes(cut, carat)) +
        geom_boxplot() +
        coord_flip() +
        tema
```

A diferença está apenas no mapeamento. 
:::

### Exercício 5.5.4 {- #exr5-5-4}

::: {.enunciado}
Um problema com boxplots é que eles foram desenvolvidos em uma era de conjuntos de dados muito menores e tendem a exibir um número proibitivamente grande de "valores fora da curva". Uma abordagem para remediar esse problema é o *letter value plot* . Instale o **lvplot** e tente usar `geom_lv()` para exibir a distribuição de preço *versus* corte. O que você aprendeu? Como você interpreta os gráficos?
:::

:::{.solution}

???

```{r}
library(lvplot)

diamonds %>%
    ggplot(aes(cut, price)) +
        geom_lv(width.method = "height") +        
        tema
```

:::

### Exercício 5.5.5 {- #exr5-5-5}

::: {.enunciado}
Compare e contraste `geom_violin()` com `geom_histogram()` facetado, ou um `geom_freqpoly()` colorido. Quais são os prós e contras de cada método?
:::

:::{.solution}
Com o polígono de frequência é mais fácil comparar os grupos, uma vez que as linhas são sobrepostas, contudo muitas vezes pode se tornar complicado visualizar o comportamento/variação de cada grupo individualmente. O violino e o histograma permitem visualizar a distribuição em cada grupo, contudo fica mais complicado fazer a comparação.

```{r}
# Violin
diamonds %>%
    ggplot(aes(cut, price)) +
        geom_violin() +
        coord_flip() +
        tema

# Histogram
diamonds %>%
    ggplot(aes(price)) +
        geom_histogram() +
        facet_wrap(~ cut, ncol = 1, scale = "free_y") +
        tema

#Frequency Polygon
diamonds %>%
    ggplot(aes(price, ..density.., color = cut)) +
    geom_freqpoly(binwidth = 500) +
    tema
```

:::

### Exercício 5.5.6 {- #exr5-5-6}

::: {.enunciado}
Se você tem um conjunto de dados pequeno, às vezes é útil usar `geom_jitter()` para ver a relação entre uma variável contínua e uma categórica. O pacote **ggbeeswarm** fornece alguns métodos similares a `geom_jitter()`. Liste-os e descreva brevemente o que cada um faz.
:::

:::{.solution}
O pacote oferece duas geoms. A primeira, `geom_quasirandom()` mistura o *jitter* com a a aparencia do gráfico violino. A segunda, `geom_beeswarm()` produz gráficos parecidos com violinos, mas com alguma sobreposição.

Em comparação ao `geom_jitter()`, o pacote `ggbeeswarm()` permite uma melhor visualização dos clusteres, caso existam. No nosso exemplo, os clusters seriam as próprias classes, ele evita que os pontos de uma classe se aproximem demais da classe ao lado, gerando uma melhor visualização. Também mantém mais ou menos agrupados as "alturas" no eixo y, isto é, o erro é colocado apenas em uma das direções.

```{r}
library(ggbeeswarm)

mpg %>%
    ggplot(aes(class, hwy)) +
        geom_point() +
        tema

mpg %>%
    ggplot(aes(class, hwy)) +
        geom_jitter() +
        tema

mpg %>%
    ggplot(aes(class, hwy)) +
        geom_quasirandom() +
        tema

mpg %>%
    ggplot(aes(class, hwy)) +
        geom_beeswarm() +
        tema
```
:::

### Exercício 5.5.7 {- #exr5-7-7}

::: {.enunciado}
Como você alteraria a escala do conjunto de dados `diamonds` para mostrar mais claramente a distribuição de corte dentro de cor  ou cor dentro de corte?
:::

::: {.solution}
Pode-se melhorar usando a proporção de `cut` dentro de `color`, porém a mudança não foi tão significativa.

```{r}
diamonds %>%
    count(color, cut) %>%
    ggplot(aes(color, cut)) +
        geom_tile(mapping = aes(fill = n)) + 
        tema

diamonds %>%
    count(color, cut) %>%
    group_by(color) %>%
    mutate(
        prop = n / sum(n)
    ) %>%
    ggplot(aes(color, cut)) +
        geom_tile(mapping = aes(fill = prop)) + 
        tema
```
:::

### Exercício 5.5.8 {- #exr5-5-8}

::: {.enunciado}
Use `geom_tile()` junto de **dplyr** para explorar como os atrasos médios dos voos variam por destino e mês. O que dificulta a leitura do gráfico? Como você poderia melhorá-lo?
:::

::: {.solution}
???

```{r}
flights %>%
    group_by(month, dest) %>%                           # Agrupar por mês e destino
    summarise(
        dep_delay = mean(dep_delay, na.rm = TRUE)       # Calcular o atraso médio
    ) %>%
    group_by(dest) %>%                                  # Agrupar pelo destino
    filter(n() == 12) %>%                               # Selecionar apenas aqueles destinos que tem informação de todos os meses
    ungroup() %>%                                       # Desagrupa pelo destino
    ggplot(aes(factor(month), dest, fill = dep_delay)) +
        geom_tile()
```

:::

### Exercício 5.5.9 {- #exr5-5-9}

::: {.enunciado}
Por que é um pouco melhor usar `aes(x = color, y = cut)` em vez de `aes(c = cut, y = color)` no exemplo anterior?
:::

::: {.solution}
???

```{r}
diamonds %>%
    count(color, cut) %>%    
    ggplot(aes(color, cut)) +
        geom_tile(mapping = aes(fill = n)) + 
        tema

diamonds %>%
    count(cut, color) %>%    
    ggplot(aes(cut, color)) +
        geom_tile(mapping = aes(fill = n)) + 
        tema
```

:::

### Exercício 5.5.10 {- #exr5-5-10}

::: {.enunciado}
Em vez de resumir a distribuição condicional com um boxplot, pode-se usar um polígono de frequência. O que você precisa considerar ao usar `cut_width()` *versus* `cut_number()`? Como isso impacta uma visualização da distribuição 2D de `carat` e `price`?
:::

::: {.solution}
Utilizamos `cut_width()` quando queremos determinar o tamanho das classes que serão exibidas e `cut_number()` quando queremos determinar o número de classes. 

Se o número total de classes for muito grande, a visualização fica comprometida. Se for pequeno demais, não captaremos comportamentos importantes.

```{r}
diamonds %>%
    ggplot(aes(carat, price)) +
        geom_boxplot(aes(group = cut_number(carat, 5)))

diamonds %>%
    ggplot(aes(price)) +
        geom_freqpoly(aes(color = cut_number(carat, 5))) +
        tema

diamonds %>%
    ggplot(aes(price)) +
        geom_freqpoly(aes(color = cut_width(carat, 1))) +
        tema
```
:::

### Exercício 5.5.11 {- #exr5-5-11}

::: {.enunciado}
Visualize a distribuição de `carat`, particionada por `price`.
:::

::: {.solution}
Inicialmente vamos utilizar boxplot para visualizar a distribuição. Vamos dividir os preços em 10 grupos.

```{r}
diamonds %>%
    ggplot(aes(cut_number(price, 10), carat)) +
        geom_boxplot() +
        coord_flip() +
        tema
```

Note que, `cut_number()` dividiu os grupos de modo a ter a mesma quantidade de registros em cada classe e isso acaba gerando classes de larguras diferentes. É mais fácil comparar classes de mesma largura, por isso vamos refazer a visualização utilizando `cut_width()`:

```{r}
diamonds %>%
    ggplot(aes(cut_width(price, 2000), carat)) +
        geom_boxplot() +
        coord_flip() +
        tema
```

A visualização ficou um pouco melhor, porém temos uma classe que inclui valores negativos. Vamos corrigir isso utilizando o argumento `boundary`:

```{r}
diamonds %>%
    ggplot(aes(cut_width(price, 2000, boundary = 0), carat)) +
        geom_boxplot() +
        coord_flip() +
        tema
```

Como existem muitos *outliers*, vamos tentar utilizar o *letter value*:

```{r}
diamonds %>%
    ggplot(aes(cut_width(price, 2000, boundary = 0), carat)) +
        geom_lv() +
        coord_flip() +
        tema
```

Para melhorar a visualização das classes, vamos também mudar a unidade de `price` de dolares para milhares de dólares, basta dividirmos os valores por 1000:

```{r}
diamonds %>%
    mutate (price = price / 1000) %>%
    ggplot(aes(cut_width(price, 2, boundary = 0), carat)) +
        geom_lv() +
        coord_flip() +
        tema
```

Agora vamos melhorar os títulos do gráfico:

```{r}
diamonds %>%
    mutate (price = price / 1000) %>%
    ggplot(aes(cut_width(price, 2, boundary = 0), carat)) +
        geom_lv() +
        coord_flip() +
        labs(
            title = "Distribuição do quilate das pedras por faixa de preço",
            y = "Quilates",
            x = "Preço (mil dólares)"
        ) +
        tema
```

O gráfico está pronto.

Note que poderíamos ter utilizado a `geom_violin()`, porém, neste caso, não teríamos uma visão muito boa dos outliers.

```{r}
diamonds %>%
    mutate (price = price / 1000) %>%
    ggplot(aes(cut_width(price, 2, boundary = 0), carat)) +
        geom_violin() +
        coord_flip() +
        labs(
            title = "Distribuição do quilate das pedras por faixa de preço",
            y = "Quilates",
            x = "Preço (mil dólares)"
        ) +
        tema
```

:::

### Exercício 5.5.12 {- #exr5-5-12}

::: {.enunciado}
Como a distribuição de preços de diamantes muito grandes se compara à de diamantes pequenos? É como você esperava ou isso lhe surpreende?
:::

::: {.solution}
???

```{r}
diamonds %>%
    ggplot(aes(cut_width(carat, 2, boundary = 0), price)) +
        geom_boxplot() +
        tema
```

:::

### Exercício 5.5.13 {- #exr5-5-13}

::: {.enunciado}
Combine duas técnicas que você aprendeu para visualizar a distribuição combinada de `cut`, `carat` e `price`.
:::

::: {.solution}
```{r}
diamonds %>%
    ggplot(aes(cut_number(carat, 5), price, color = cut)) +
        geom_boxplot() +
        tema
```

```{r}
diamonds %>%
    ggplot(aes(carat, price)) +
        geom_hex() +
        facet_wrap(~ cut, ncol = 1) +
        tema
```

```{r}
diamonds %>%
    ggplot(aes(cut_number(carat, 10), cut, fill = desc(price))) +
        geom_tile() +        
        tema
```
:::

### Exercício 5.5.14 {- #exr5-5-14}

::: {.enunciado}
Gráficos bidimensionais revelam pontos fora da curva que não são visíveis em gráficos unidimensionais. Por exemplo, alguns pontos no gráfico a seguir tem uma combinação incomum de valores de `x` e `y`, que faz pontos ficarem fora da curva, mesmo embora seus valores `x` e `y` pareçam normais quando examidanos separadamente.

```{r}
ggplot(data = diamonds) +
    geom_point(mapping = aes(x = x, y = y)) +
    coord_cartesian(xlim = c(4, 11), ylim = c(4, 11)) +
    tema
```

Por que um diagrama de dispersão é uma exibição melhor do que um diagrama de caixa neste caso?
:::

::: {.solution}
Como os valores de `x` e `y` são fortemente relacionados, os outliers não vão aparecer no extremo de ums ou outra coordenada, mas em proporções desigaia dos diamantes.
:::

## Padrões e modelos

Não temos exercícios nesta seção.

## Chamadas `ggplot2`

Não temos exercícios nesta seção.

## Aprendendo mais

Não temos exercícios nesta seção.

<!--chapter:end:chapters/05-analise-exploratoria-de-dados.Rmd-->

# Fluxo de trabalho: projetos

## O que é real?

Não temos exercícios nesta seção.

## Onde sua análise vive?

Não temos exercícios nesta seção.

## Caminhos e diretórios

Não temos exercícios nesta seção.

## Projetos RStudio

Não temos exercícios nesta seção.

## Resumo

Não temos exercícios nesta seção.

<!--chapter:end:chapters/06-fluxo-de-trabalho-projetos.Rmd-->

# (PART) Wrangle {-}

# Tibbles com `tibble`

## Introdução

Não temos exercícios nesta seção.

## Criando tibbles

Não temos exercícios nesta seção.

## Tibbles _versus_ `data.frame`

Não temos exercícios nesta seção.

## Interagindo com códigos mais antigos

### Exercício 7.4.1 {- #exr7-4-1}

::: {.enunciado}
 Como você consegue dizer se um objeto é um tibble? (Dica: tente imprimir `mtcarts`, que é um dat
:::

::: {.solution}
```{r}
print(mtcars)
print(as.tibble(mtcars))

str(mtcars)
str(as.tibble(mtcars))

rownames(mtcars)
row.names(as.tibble(mtcars))
```

Há várias formas que podem nos ajudar a identificar se o conjunto de dados está organizado como um data frame padrão ou como um tibble:

- Ao utilizar o comando `print()`, um data frame comum imprime todas as observações, enquanto um tibble imprime apenas as 10 primeiras;
- Ao utilizar a função `str()`, o tipo de objeto é impresso;
- Ao utilizar a função `rownames()`, um data frame exibirá os nomes das observações (se houver), enquanto um tibble exibirá sempre um sequ~encia numérica (???).
:::

### Exercício 7.4.2 {- #exr7-4-2}

::: {.enunciado}
Compare e constraste as seguintes operações em `data.frame` e tibble equivalente. Qual é a diferença? Por que os comportamentos do data frame padrão podem lhe causar frustração?

```
df <- data.frame(abc = 1, xyz = "a")
df$x
df[, "xyz"]
df[, c("abc", "xyz")]
```
:::

::: {.solution}
Inicialmente vamos definir um tibble com o mesmo conteúdo do data frame proposto.

```{r}
tb <- tibble(abc = 1, xyz = "a")
```

A seguir, executaremos os comandos correspondentes para avaliar a saida.

```{r}
tb$x
tb[, "xyz"]
tb[, c("abc", "xyz")]
```

Concluímos que:

- Ao utilizar o operador `$`, o data frame busca exibir a primeira (?) coluna que contenha `x`, enquando num tibble, busca-se a coluna nomeada exatamente como `x`;
- Ao utilizar o nome completo de uma única variável com o operador `[`, um data frame imprime um vetor ou um valor singular, enquanto um tibble exibe sempre outro tibble;
- ao usar o operador `[` passando um vetor de variáveis, o data frame padrão retorna outro data frame e um tibble retorna outro tibble. Neste caso o comportamento é similar.
:::

### Exercício 7.4.3 {- #exr7-4-3}

::: {.enunciado}
Se você tem o nome de uma variável armazenada em um objeto, por exemplo `var <- "mpg"`, como você pode extrair a variável de referência para um tibble?
:::

::: {.solution}
Tanto para o data frame quanto para um tibble, é possível utilizar o operador `[[`.

```{r}
var <- "mpg"
mtcars[[var]]
as.tibble(mtcars)[[var]]
```

:::

### Exercício 7.4.4 {- #exr7-4-4}

::: {.enunciado}
Pratique referir-se a nomes de variáveis não sintáticos, no data frame a seguir:

```{r}
annoyng <- tibble(
    `1` = 1:10,
    `2` = `1` * 2 + rnorm(length(`1`))
)
```

a. Extrair a variável chamada 1.
b. Plotar um diagrama de dispersão de 1 *versus* 2.
c. Criar uma nova coluna chamada 3 que é 2 dividido por 1.
d. Renomear as colunas para `one`, `two` e `three`.
:::

::: {.solution}
a. Extrair a variável chamada 1.

```{r}
annoyng$ `1`
```

b. Plotar um diagrama de dispersão de 1 *versus* 2.

```{r}
annoyng %>%
    ggplot(aes(`1`, `2`)) +
        geom_point()
```

c. Criar uma nova coluna chamada 3 que é 2 dividido por 1.

```{r}
annoyng$`3` <- annoyng$`2` / annoyng$`1`
```

d. Renomear as colunas para `one`, `two` e `three`.

```{r}
colnames(annoyng) <- c("one", "two", "three")
annoyng
```

:::

### Exercício 7.4.5 {- #exr7-4-5}

::: {.enunciado}
O que `tibble::enframe()` faz? Quando você pode usá-lo?
:::

::: {.solution}
Transforma um vetor de valores atômicos ou lista em um tibble de 2 colunas. É útil quando necessitarmos transformar um vetor em um dicionário ou uma lista de pares (nome, valor), por exemplo. 

```{r}
x <- letters
enframe(x)
```

:::

### Exercício 7.4.6 {- #exr7-4-6}

::: {.enunciado}
Que opção controla quantos nomes de colunas adicionais são impressos no rodapé de um tibble?
:::

::: {.solution}
Pode-se usar a opção `tibble.max_extra_cols`.

```{r}
options(tibble.width = 30, tibble.max_extra_cols = 4)
print(as.tibble(mtcars))
```

:::

<!--chapter:end:chapters/07-tibbles-com-tibble.Rmd-->

# Importando dados com `readr`

## Introdução

Não temos exercícios nesta seção.

## Começando

### Exercício 8.2.1 {- #exr8-2-1}

::: {.enunciado}
Qual função você usaria para ler um arquivo em que os campos são separados por "|"?
:::

::: {.solution}
A melhor opção é utilizar a função `read_delim()` indicando o `|` para o argumento `delim`.

```{r}
read_delim("a | b | c\n1 | 2 | 3", delim = " | ")
```

:::

### Exercício 8.2.2 {- #exr8-2-2}

::: {.enunciado}
Além de `file`, `skip` e `comment`, quais outros argumentos `read_csv()` e `read_tsv()` têm em comum?
:::

::: {.solution}
Também são comuns os argumentos: `col_names`, `col_types`, `col_select`, `id`, `locale`, `na`, `quote`, `n_max`, `guess_max`, `progress`, `name_repair`, `num_threads`, `show_col_types`, `skip_empty_rows` e `lazy`.
:::

### Exercício 8.2.3 {- #exr8-2-3}

::: {.enunciado}
Quais são os argumentos importantes de `read_fwf()`?
:::

::: {.solution}
???

Eu chutaria `n`, `widths`, `start` e `end`.
:::

### Exercício 8.2.4 {- #exr8-2-4}

::: {.enunciado}
Às vezes, strings em um arquivo CSV contém vírgulas. Para evitar que causem problemas, elas precisam ser cercadas por um caractere de aspas, como " ou '. Por convenção, `read_csv()` supõe que as aspas serão ", e se você quiser mudá-las, precisará usar `read_delim()`. Quais argumentos você precisa especificar para ler o texto a seguir em um data frame?

**"x,y\\n1, 1, 'a, b'"**

:::

::: {.solution}
É possível utilizar o argumento `quote` para indicar caractere de citação.

```
read_csv("x, y/n1, 'a, b'", quote = "/'")
```

:::

### Exercício 8.2.5 {- #exr8-2-5}

::: {.enunciado}
Identifique o que há de errado com cada um dos seguintes arquivos CSV em linha. O que acontece quando você executa o código?

```
read_csv("a, b\n1, 2, 3\n4, 5, 6")
read_csv("a, b, c\n1, 2\n1, 2, 3, 4")
read_csv("a, b\n\"1")
read_csv("a, b\n1, 2\na, b")
read_csv("a;b\n1; 3")
```
:::

::: {.solution}
Para o primeiro caso, `read_csv("a, b\n1, 2, 3\n4, 5, 6")` o problema é que a linha de cabeçalhos tem apenas 2 colunas, enquanto as demais tem 3. O correto seria usar:

```{r}
read_csv("a, b, c\n1, 2, 3\n4, 5, 6")
```

Para o segundo item, `read_csv("a, b, c\n1, 2\n1, 2, 3, 4")`, o problema é que há 4 colunas na segunda linha, 2 colunas na segunda e três na linha de cabeçalho. Uma correção possível seria:

```{r}
read_csv("a, b, c, d\n1, 2, . , .\n1, 2, 3, 4", na = c("."))
```

No terceiro exemplo, `read_csv("a, b\n\"1")`, há dois problemas: não há indicação do valor da variável `b` na segunda linha e há um caracter `\` que parece estar perdido na linha. Uma solução possível é:

```{r}
read_csv("a, b\n\"1\", NA")
```

No caso de `read_csv("a, b\n1, 2\na, b")`, não parece haver problemas. A menos que a última linha seja uma repetição do cabeçalho.

```{r}
read_csv("a, b\n1, 2\na, b")
```

Para o último exemplo, `read_csv("a;b\n1; 3")`, o erro é que o separador é `;` e não `,`.

```{r}
read_csv2("a;b\n1; 3")
```

:::

## Analisando um vetor

### Exercício 8.3.1 {- #exr8-3-1}

::: {.enunciado}
Quais são os argumentos mais importantes de `locale()`?
:::

::: {.solution}
Os argumentos mais importantes são `encoding`, `decimal_mark`, `grouping_mark`.
:::

### Exercício 8.3.2 {- #exr8-3-2}

::: {.enunciado}
O que acontece se você tentar configurar `decimal_mark` e `grouping_mark` com o mesmo caractere? O que acontece com o valor padrão de `grouping_mark` quando você configura `decimal_mark` como ","? O que acontece com o valor padrão de `decimal_mark` quando você configura `grouping_mark` como "."?
:::

::: {.solution}
```{r}
locale(grouping_mark = ".")
```

- Não é possível configurar `decimal_mark` e `grouping_mark` com o mesmo caractere. Se isto ocorrer, teremos um erro.
- Se usarmos `decimal_mark` como ",", o valor de `grouping_mark` é automaticamente alterado para ".";
- Se usarmos "." para `grouping_mark`, o valor default de `decimal_mark` é alterado automaticamente para ",";
:::

### Exercício 8.3.3 {- #exr8-3-3}

::: {.enunciado}
Eu não discuti as opções `date_format` e `time_format` para `locale()`. O que elas fazem? Construa um exemplo que mostre quando elas podem ser úteis.
:::

::: {.solution}
Servem para indicar o formato padrão de data e hora, respectivamente.

```{r}
parse_date("20-10-01", locale = locale(date_format = "%y-%m-%d", time_format = "%h:%M:%S"))
```

:::

### Exercício 8.3.4 {- #exr8-3-4}

::: {.enunciado}
Se você mora fora dos Estados Unidos, crie um novo objeto de localização que englobe as configurações para os tipos de arquivo que você mais comumente lê.
:::

::: {.solution}
```{r}
locale(
    decimal_mark = ",",
    grouping_mark = ".",
    date_format = "%d/%m/%Y",
    time_format = "%H:%M:%S",
    date_names = "pt"
)
```

:::

### Exercício 8.3.5 {- #exr8-3-5}

::: {.enunciado}
Qual a diferença entre `read_csv()` e `read_csv2()`?
:::

::: {.solution}
Enquanto `read_csv()` utiliza a vírgula como delimitador, o `read_csv2()` utiliza o ponto-e-vírgula.
:::

### Exercício 8.3.6 {- #exr8-3-6}

::: {.enunciado}
Quais são as codificações mais usadas na Europa? Quais as codificações mais usadas na Ásia? Procure no Google para descobrir.
:::

::: {.solution}
???
:::

### Exercício 8.3.7 {- #exr8-3-7}

::: {.enunciado}
Gere uma string de formatação correta para analisar cada uma das datas e horas a seguir:

```{r}
d1 <- "January 1, 2010"
d2 <- "2015-Mar-07"
d3 <- "06-Jun-2016"
d4 <- c("August 19 (2015)", "July 1 (2015)")
d5 <- "12/30/14" # Dec 30, 2014
t1 <- "1705"
t2 <- "11:15:10.12 PM"
```
:::

::: {.solution}
```{r}
parse_date(d1, "%B %d, %Y")
parse_date(d2, "%Y-%b-%d")
parse_date(d3, "%d-%b-%Y")
parse_date(d4, "%B %d (%Y)")
parse_date(d5, "%m/%d/%y")

parse_time(t1, "%H%M")
parse_time(t2, "%I:%M:%OS %p")
```
:::

## Analisando um arquivo

Não temos exercícios nesta seção.

## Escrevendo em um arquivo

Não temos exercícios nesta seção.

## Outros tipos de dados

Não temos exercícios nesta seção.

<!--chapter:end:chapters/08-importando-dados-com-readr.Rmd-->

# Arrumando dados com `tidyr`

## Introdução

Não temos exercícios nesta seção.

## Dados arrumados (Tidy Data)

### Exercício 9.2.1 {- #exr9-2-1}

::: {.enunciado}
Usando a prosa, descreva como as variáveis e as observações estão organizadas em cada uma das tabelas de exemplo.
:::

::: {.solution}
:::

### Exercício 9.2.2 {- #exr9-2-2}

::: {.enunciado}
Calcule o `rate` para `table2` e `table4a + table 4b`. Você precisará realizar quatro operações:

a. Extraia o número de casos de TB por país por ano.
b. Extraia a população correspondente por país por ano.
c. Divida os casos por população e multiplique por 10.000.
d. Armazene no local adequado.

Com qual representação é mais fácil trabalhar? Com qual é mais difícil? Por quê?
:::

::: {.solution}
:::

### Exercício 9.2.3 {- #exr9-2-3}

::: {.enunciado}
Recrie o gráfico mostrando a mudança nos casos com o passar do tempo usando `table2`, em vez de `table1`. O que você precsa fazer primeiro?
:::

::: {.solution}
:::

## Espalhando e reunindo

### Exercício 9.3.1 {- #exr9-3-1}

::: {.enunciado}
Por que `gather()` e `spread()` não são perfeitamente simétricos? Considere cuidadosamente o exemplo a seguir:

```
stocks <- tibble(
  year   = c(2015, 2012, 2016, 2016),
  half   = c(   1,    2,    1,    2),
  return = c(1.88, 0.59, 0.92, 0.17)
)

stocks %>%
  spread(year, return) %>%
  gather("year", "return", `2015`:`2016`)
```

(Dica: observe os tipos de variáveis e pense sobre *nomes* de colunas.)

Ambos `spread()` e `gather()` tês um argumento `convert`. O que ele faz?
:::

::: {.solution}
:::

### Exercício 9.3.2 {- #exr9-3-2}

::: {.enunciado}
Por que este código falha?

```
table4a %>%
  gather(199, 2000, key = "year", value = "cases")
```
:::

::: {.solution}
:::

### Exercício 9.3.3 {- #exr9-3-3}

::: {.enunciado}
Por que espalhar esse tibble falha? Como você poderia adicionar uma nova coluna para corrigir o problema?

```
people <- tribble(
  ~name,               ~key,    ~value,
  #------------------/---------/-------
  "Phillip Woods",    "age",    45,
  "Phillip Woods",    "height", 186,
  "Phillip Woods",    "age",    50,
  "Jessica Cordero",  "age",    37,
  "Jessica Cordero",  "height", 156
)
```
:::

::: {.solution}
:::

### Exercício 9.3.4 {- #exr9-3-4}

::: {.enunciado}
Arrume este tibble simples. Você precisará espalhá-lo ou reuní-lo? Quais são as variáveis?

```{r}
preg <- tribble(
  ~pregnant,    ~male,    ~female,
  "yes",        NA,       10,
  "no",         20,       12
)
```
:::

::: {.solution}
:::

## Separando e unindo

### Exercício 9.4.1 {- #exr9-4-1}

::: {.enunciado}
O que os argumentos `extra` e `fill` fazem em `separate()`? Experimente as várias opções para os dois conjuntos de dados de brinquedos a seguir:

```
tibble(x = c("a,b,c", "d,e,f,g", "h,i,j")) %>%
  separate(x,c("one", "two", "three"))
  
tibble(x = c("a,b,c", "d,e", "f,g,i")) %>%
  separate(x,c("one", "two", "three"))
```
:::

::: {.solution}
:::

### Exercício 9.4.2 {- #exr9-4-2}

::: {.enunciado}
`unite()` e `separate()` têm um argumento `remove`. O que ele faz? Por que você o configuraria como `FALSE`?
:::

::: {.solution}
:::

### Exercício 9.4.3 {- #exr9-4-3}

::: {.enunciado}
Compare e contranste `separate()` e `extract()`. Por que há três variações de separação (por posição, por separador e com grupos), mas apenas uma para união?
:::

::: {.solution}
:::

## Valores faltantes

### Exercício 9.5.1 {- #exr9-5-1}

::: {.enunciado}
Compare e contraste os argumentos `fill` de `spread()` e `complete()`.
:::

::: {.solution}
:::

### Exercício 9.5.2 {- #exr9-5-2}

::: {.enunciado}
O que o argumento de direção de `fill()` faz?
:::

::: {.solution}
:::

## Estudo de caso

### Exercício 9.6.1 {- #exr9-6-1}

::: {.enunciado}
Neste estudo de caso eu configuro `na.rm = TRUE` só para facilitar a verificação de que tínhamos os valores corretos. Isso é razoável? Pense sobre como os valores faltantes são representados nesse conjunto de dados. Há valores faltantes implícitos? qual é a diferença entre um `NA`e zero?
:::

::: {.solution}
:::

### Exercício 9.6.2 {- #exr9-6-2}

::: {.enunciado}
O que acontece se você negligenciar o passo `mutate()`? (`mutate(key = stringr::str_replace(key, "newrel", "new_rel"))`)?
:::

::: {.solution}
:::

### Exercício 9.6.3 {- #exr9-6-3}

::: {.enunciado}
Afirmei que `iso2` e `iso3` eram redundantes com `country`. Confirme essa afirmação.
:::

::: {.solution}
:::

### Exercício 9.6.4 {- #exr9-6-4}

::: {.enunciado}
Para cada país, ano e gênero, calcule o número total de casos de TB. Faça uma visualização informativa dos dados.
:::

::: {.solution}
:::

## Dados desarrumados (não tidy)

Não temos exercícios nesta seção.

<!--chapter:end:chapters/09-arrumando-dados-com-tidyr.Rmd-->

# Dados relacionais com `dplyr`

## Introdução

## `nycflights13`

## Chaves (keys)

## Mutating joins

## Filtering joins

## Problemas de joins

## Operações de conjuntos

<!--chapter:end:chapters/10-dados-relacionais-com-dplyr.Rmd-->

# Strings com `stringr`

## Introdução

## O básico de string

## Combinando padrões com expressões regulares

## Ferramentas 

## Outros tipos de padrões

## Outros usos para expressões regulares

## `string`

<!--chapter:end:chapters/11-strings-com-stringr.Rmd-->

# Fatores com `forcats`

## Introdução

## Criando fatores

## General Social Survey

## Modificando a ordem dos fatores

## Modificando níveis de fatores

<!--chapter:end:chapters/12-fatores-com-forcats.Rmd-->

# Datas e horas com `lubridate`

## Introdução

## Criando data/horas

## Componentes de data-hora

## Intervalos de tempo

## Fusos horários

<!--chapter:end:chapters/13-datas-e-horas-com-lubridate.Rmd-->

# (PART) Programar {-}

# Pipes com `magrittr`

## Introdução

## Alternativas ao piping

## Quando não usar o pipe

## Outras ferramentas do `magrittr`

<!--chapter:end:chapters/14-pipes-com-magrittr.Rmd-->

# Funções

## Introdução

## Quando você deveria escrever uma função?

## Funções são para humanos e computadores

## Execução condicional

## Argumentos de funções 

## Retorno de valores

## Ambiente

<!--chapter:end:chapters/15-funcoes.Rmd-->

# Vetores

## Introdução

## O Básico de vetores

## Tipos importantes de vetores atômicos 

## Usando vetores atómicos

## Vetores recursivos (listas)

## Atributos

## Vetores aumentados

<!--chapter:end:chapters/16-vetores.Rmd-->

# Iteração com `purrr`

## Introdução

## Loops `for`

## Variações do loop `for`

## Loops `for` _versus_ funcionais

## As funções `map`

## Lidando com falhas

## Fazendo `map` com vários argumentos

## Walk

## Outros padrões para loops `for`

<!--chapter:end:chapters/17-iteracao-com-purrr.Rmd-->

# (PART) Modelar

# O básico de modelos com `modelr`

## Introdução

## Um modelo simples

## Visualizando modelos fórmulas e famílias de modelos

## Valores faltantes

## Outras famílias de modelos

<!--chapter:end:chapters/18-o-basico-de-modelos-com-modelr.Rmd-->

# Construção de modelos

## Introdução

## Por que diamantes de baixa qualidade são mais caros? 

## O que afeta o número de voos diários?

## Aprendendo mais sobre modelos

<!--chapter:end:chapters/19-construcao-de-modelos.Rmd-->

# Muitos modelos com `purrr` e `broom`

## Introdução

## `gapminder`

## List-columns

## Criando list-columns

## Simplificando list-columns 

## Criando dados tidy com `broom`


<!--chapter:end:chapters/20-muitos-modelos-com-purrr-e-broom.Rmd-->

# (PART) Comunicar {-}

# R Markdown

## Introdução

## O Básico de R Markdown

## Formatação de texto com markdown

## Trechos de código

## Resolução de problemas

## Header YAML

## Aprendendo mais

<!--chapter:end:chapters/21-r-markdown.Rmd-->

# Gráficos para comunicação com `ggplot2`

## Introdução

## Rótulo

## Anotações

## Escalas

## Dando zoom

## Temas

## Salvando seus gráficos

## Aprendendo mais

<!--chapter:end:chapters/22-graficos-para-comunicacao-com-ggplot2.Rmd-->

# Formatos R Markdown

## Introdução

## Opções de saída

## Documentos

## Notebooks

## Apresentações

## Dashboards

## Interatividade

## Sites

## Outros formatos

## Aprendendo mais

<!--chapter:end:chapters/23-formatos-r-markdown.Rmd-->

# Fluxo de trabalho de R Markdown

<!--chapter:end:chapters/24-fluxo-de-trabalho-de-r-markdown.Rmd-->

`r if (knitr::is_html_output()) '
# Referências {-}
'`

<!--chapter:end:chapters/25-referencias.Rmd-->

